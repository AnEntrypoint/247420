<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>247420 - Digital Dive Bar Videos üçª | TV Room</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">

    <!-- SEO Meta Tags -->
    <meta name="description" content="247420 Digital Dive Bar TV Room - Where drunk hackers and meme culturists gather to watch chaotic broadcasts. Featuring questionable content, late-night programming, and bar regulars on screen.">
    <meta name="keywords" content="247420 digital dive bar, tv room, drunk hackers, meme culturists, chaotic broadcasts, bar television, late night programming, questionable content">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://247420.247247420.xyz/videos-thread.html">

    <!-- Open Graph Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://247420.247247420.xyz/videos-thread.html">
    <meta property="og:title" content="247420 | Digital Dive Bar TV Room üçª">
    <meta property="og:description" content="Where drunk hackers and meme culturists gather to watch chaotic broadcasts and questionable late-night programming.">
    <meta property="og:image" content="https://247420.247247420.xyz/logo.gif">
    <meta property="og:site_name" content="247420 Digital Dive Bar">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="247420 | Digital Dive Bar TV Room üçª">
    <meta name="twitter:description" content="Where drunk hackers and meme culturists gather to watch chaotic broadcasts.">
    <meta name="twitter:image" content="https://247420.247247420.xyz/logo.gif">

    <link href="https://fonts.googleapis.com/css2?family=VT323:wght@400;700&family=Share+Tech+Mono&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="css/videos-thread.css">
  <link rel="stylesheet" href="/components/navbar.css">
  <link rel="stylesheet" crossorigin href="/assets/style-ERVDcyL7.css">
  <link rel="stylesheet" crossorigin href="/assets/lore-D6iLehCu.css">
</head>
<body>
    <div class="terminal-scanlines"></div>
    <div class="terminal-flicker"></div>

    <!-- Beer Drip Animations -->
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>

    <!-- Navigation -->
    <div id="navbar-container"></div>

    <div class="container">
        <div class="hero-section">
            <h1 class="hero-title">üçª 247420 Dive Bar TV Room</h1>
            <p class="hero-subtitle">Where Drunk Hackers & Meme Culturists Watch Chaotic Broadcasts</p>
        </div>

    <div class="tv-container">
        <div class="tv-skin-overlay"></div>
        <div class="fullscreen-hint" id="fullscreenHint" style="display: none;">PRESS ESC TO EXIT FULLSCREEN</div>
        <div class="tv-screen-wrapper">
            <div class="tv-screen">
                <video id="currentVideo" class="video-player" autoplay muted></video>
                <video id="nextVideo" class="video-player" style="display: none;" preload="auto"></video>
                <video id="thirdVideo" class="video-player" style="display: none;" preload="auto"></video>
                <div class="scan-lines"></div>
                <div class="tv-static" id="static">
                    <canvas id="noiseCanvas"></canvas>
                </div>
                <div class="vignette"></div>
                <div class="loading-text" id="loadingText">INITIALIZING QUANTUM STREAM...</div>
                <div class="now-playing" id="nowPlaying" style="display: none;">
                    <i class="fas fa-satellite-dish"></i> TRANSMITTING: DIGITAL SIGNAL
                </div>
                <div class="url-display">
                    247420.247420.xyz
                </div>
                <div class="logo-overlay">
                    <div class="qr-code">
                        <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=https://schwpe.247420.xyz" alt="QR Code" class="qr-image">
                    </div>
                    <img src="/logo.gif" alt="Logo" class="logo-image">
                </div>
            </div>
            <!-- Audio noise/static element -->
            <audio id="staticNoise" loop preload="auto"></audio>
        </div>

        <!-- Video controls removed for clean viewing experience -->

        </div>
    </div>

    <script>
        class Schwelevision {
            constructor() {
                this.videos = [];
                this.playedVideos = new Set();
                this.currentVideoElement = document.getElementById('currentVideo');
                this.nextVideoElement = document.getElementById('nextVideo');
                this.thirdVideoElement = document.getElementById('thirdVideo');
                this.staticNoiseElement = document.getElementById('staticNoise');
                this.staticElement = document.getElementById('static');
                this.noiseCanvas = document.getElementById('noiseCanvas');
                this.noiseCtx = this.noiseCanvas.getContext('2d');
                this.currentIndex = -1;

                // Check if loaded in iframe and enable embed mode
                this.checkIframeMode();
                this.nextIndex = -1;
                this.thirdIndex = -1;
                this.volume = 0;
                this.isDragging = false;
                this.noiseAnimationId = null;
                this.isVideoPreloaded = false;
                this.isThirdVideoPreloaded = false;

                // Synchronized programming system
                this.PROGRAM_SEED = 247420;
                this.schedule = [];
                this.currentProgramIndex = 0;
                this.scheduledPlayTimeout = null;

                // Weekly schedule system
                this.weeklySchedule = null;
                this.currentWeek = null;
                this.scheduleStart = null;
                this.isScheduledVideoPlaying = false;

                // Loop scheduling system
                this.loopSchedule = [];
                this.loopDuration = 3600000; // 1 hour default
                this.epochStart = new Date('2025-01-01T00:00:00Z').getTime();

                this.initAudioNoise();
                this.initNoiseCanvas();
            }

            checkIframeMode() {
                // Check if we're in an iframe
                if (window.self !== window.top) {
                    console.log('üì∫ Schwelevision loaded in iframe - enabling embed mode');
                    document.body.classList.add('iframe-mode');

                    // Optionally, we can also communicate with parent window
                    try {
                        window.parent.postMessage({
                            type: 'schwelevision-ready',
                            aspectRatio: '4:3',
                            isFullscreen: true
                        }, '*');
                    } catch (e) {
                        console.log('üì∫ Cross-origin iframe detected');
                    }
                }
            }

            async init() {
                await this.loadVideos();
                await this.loadWeeklySchedule();
                this.setupEventListeners();
                this.setupAudioInteraction();
                this.startNoiseAnimation();
                this.generateProgramSchedule();
                await this.startHybridBroadcast();
            }

            async loadVideos() {
                try {
                    const response = await fetch('/saved_videos.json');
                    if (!response.ok) throw new Error('Failed to fetch videos');

                    this.videos = await response.json();

                    // Create loop schedule from videos for continuous programming
                    if (Object.keys(this.videos).length > 0) {
                        this.createLoopSchedule();
                    }

                    // If no videos loaded, create a default test video
                    if (Object.keys(this.videos).length === 0) {
                        this.videos = {
                            "test-video.mp4": {
                                "title": "Test Video for 247420",
                                "description": "A test video to verify the video player functionality",
                                "duration": 30,
                                "filename": "test-video.mp4"
                            }
                        };
                        console.log('üì∫ Using default test video');
                    }

                    // Convert videos object to array format for easier indexing
                    this.videos = Object.keys(this.videos).map(filename => ({
                        filename: filename,
                        ...this.videos[filename]
                    }));

                    console.log(`üì∫ Loaded ${this.videos.length} videos for Schwelevision`);
                } catch (error) {
                    console.error('‚ùå Error loading videos:', error);
                    // Create fallback video data
                    this.videos = [{
                        "filename": "test-video.mp4",
                        "title": "Test Video for 247420",
                        "description": "A test video to verify the video player functionality",
                        "duration": 30
                    }];
                    console.log('üì∫ Using fallback test video');
                    document.getElementById('loadingText').textContent = 'TEST SIGNAL';
                }
            }

            createLoopSchedule() {
                const videoArray = Object.keys(this.videos).map(filename => ({
                    filename: filename,
                    ...this.videos[filename]
                }));

                this.loopSchedule = [];
                let offsetMs = 0;

                // Create continuous loop from available videos
                while (offsetMs < this.loopDuration) {
                    for (const video of videoArray) {
                        if (offsetMs >= this.loopDuration) break;

                        const duration = (video.duration || 30) * 1000;
                        this.loopSchedule.push({
                            filename: video.filename,
                            duration: duration,
                            offsetMs: offsetMs,
                            videoIndex: this.videos.findIndex(v => v.filename === video.filename)
                        });

                        offsetMs += duration + 2000; // 2 second gap between videos
                    }
                }

                console.log(`üì∫ Created loop schedule with ${this.loopSchedule.length} slots, duration: ${(this.loopDuration / 60000).toFixed(1)}min`);
            }

            async loadWeeklySchedule() {
                try {
                    const currentWeek = this.getCurrentWeek();
                    await this.loadWeekData(currentWeek);
                    console.log(`üìÖ Loaded weekly schedule for week ${currentWeek}`);
                } catch (error) {
                    console.log('‚ö†Ô∏è Could not load weekly schedule, using default programming:', error.message);
                    this.weeklySchedule = null;
                }
            }

            getCurrentWeek() {
                const now = new Date();
                const gmt = Date.UTC(
                    now.getUTCFullYear(),
                    now.getUTCMonth(),
                    now.getUTCDate(),
                    now.getUTCHours(),
                    now.getUTCMinutes(),
                    now.getUTCSeconds()
                );

                const start = new Date('2025-10-11T00:00:00Z');
                const elapsed = gmt - start.getTime();
                if (elapsed < 0) return 1;

                const week = Math.floor(elapsed / (7 * 24 * 60 * 60 * 1000)) + 1;
                return week;
            }

            async loadWeekData(week) {
                try {
                    const response = await fetch(`/schedule_weeks/week_${week}.json`);
                    if (!response.ok) {
                        throw new Error(`Week ${week} not found`);
                    }

                    const scheduleData = await response.json();
                    this.weeklySchedule = scheduleData;
                    this.scheduleStart = new Date(scheduleData.m.start);
                    this.currentWeek = week;
                } catch (error) {
                    throw new Error(`Failed to load week ${week}: ${error.message}`);
                }
            }

            async getCurrentScheduledVideo() {
                if (!this.weeklySchedule) return null;

                const now = new Date();
                const gmt = Date.UTC(
                    now.getUTCFullYear(),
                    now.getUTCMonth(),
                    now.getUTCDate(),
                    now.getUTCHours(),
                    now.getUTCMinutes(),
                    now.getUTCSeconds()
                );

                if (this.scheduleStart) {
                    const scheduleStartGMT = Date.UTC(
                        this.scheduleStart.getUTCFullYear(),
                        this.scheduleStart.getUTCMonth(),
                        this.scheduleStart.getUTCDate(),
                        this.scheduleStart.getUTCHours(),
                        this.scheduleStart.getUTCMinutes(),
                        this.scheduleStart.getUTCSeconds()
                    );

                    const elapsedInWeek = gmt - scheduleStartGMT;
                    if (elapsedInWeek < 0) return null;

                    const day = Math.floor(elapsedInWeek / (24 * 60 * 60 * 1000));
                    const hour = Math.floor((elapsedInWeek % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));

                    const scheduleStartDay = 6; // Saturday
                    const currentDay = (scheduleStartDay + day) % 7;
                    const dayIndex = currentDay === 0 ? 6 : currentDay - 1;
                    const dayName = this.weeklySchedule.m.days[dayIndex];

                    const slots = this.weeklySchedule.s.filter(s =>
                        s.d === dayName && this.parseTime(s.t) === hour
                    );

                    if (slots.length === 0) return null;

                    const slot = slots[0];
                    const video = this.weeklySchedule.v[slot.v];

                    if (video) {
                        return {
                            ...video,
                            duration: (video.du || slot.du || 30) * 1000,
                            filename: video.filename || `scheduled_${slot.v}.mp4`
                        };
                    }
                }

                return null;
            }

            parseTime(timeStr) {
                const match = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!match) return 0;

                let hour = parseInt(match[1]);
                const period = match[3];
                if (period === 'PM' && hour !== 12) hour += 12;
                if (period === 'AM' && hour === 12) hour = 0;
                return hour;
            }

            seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }

            generateProgramSchedule() {
                const now = Date.now();
                const elapsedSinceEpoch = now - this.epochStart;
                const currentLoopPosition = elapsedSinceEpoch % this.loopDuration;

                const currentSlot = this.loopSchedule.find(slot =>
                    slot.offsetMs <= currentLoopPosition && slot.offsetMs + slot.duration > currentLoopPosition
                );

                if (currentSlot) {
                    this.currentProgramIndex = this.loopSchedule.indexOf(currentSlot);
                    console.log(`üì∫ Synced to loop position ${this.currentProgramIndex}: ${currentSlot.filename}`);
                } else {
                    this.currentProgramIndex = this.loopSchedule.findIndex(slot => slot.offsetMs > currentLoopPosition);
                    if (this.currentProgramIndex === -1) this.currentProgramIndex = 0;
                    console.log(`üì∫ Waiting for next program at index ${this.currentProgramIndex}`);
                }
            }

                  async startHybridBroadcast() {
                // Check for scheduled video first
                const scheduledVideo = await this.getCurrentScheduledVideo();

                if (scheduledVideo && scheduledVideo.filename) {
                    console.log(`üìÖ Scheduled video detected: ${scheduledVideo.show || scheduledVideo.filename}`);
                    await this.playWeeklyScheduledVideo(scheduledVideo);
                    this.isScheduledVideoPlaying = true;
                } else {
                    // No scheduled video, play regular 247420 content
                    console.log('üì∫ No scheduled video, playing regular 247420 content');
                    this.isScheduledVideoPlaying = false;
                    await this.startSynchronizedBroadcast();
                }
            }

            async playWeeklyScheduledVideo(video) {
                // Show static briefly before scheduled content
                this.staticElement.classList.add('active', 'temporal-refresh');
                this.playStaticNoise();

                const videoPath = video.filename.startsWith('http')
                    ? video.filename
                    : `/saved_videos/${video.filename}`;

                this.currentVideoElement.src = videoPath;
                this.currentVideoElement.volume = this.volume / 100;
                this.currentVideoElement.muted = this.volume === 0;
                this.currentVideoElement.preload = 'auto';
                this.currentVideoElement.load();

                try {
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            console.log('‚ö†Ô∏è Scheduled video timeout, playing anyway');
                            resolve();
                        }, 10000);

                        this.currentVideoElement.addEventListener('canplay', () => {
                            clearTimeout(timeout);
                            resolve();
                        }, { once: true });

                        this.currentVideoElement.addEventListener('error', (e) => {
                            clearTimeout(timeout);
                            reject(e);
                        }, { once: true });
                    });

                    // Clear static and play scheduled video
                    this.staticElement.classList.remove('active', 'temporal-refresh');
                    this.stopStaticNoise();

                    document.getElementById('loadingText').style.display = 'none';
                    document.getElementById('nowPlaying').style.display = 'block';
                    document.getElementById('nowPlaying').innerHTML = `<i class="fas fa-satellite-dish"></i> SCHEDULED: ${video.show || video.filename}`;

                    await this.currentVideoElement.play();

                    // Set timeout for video end
                    setTimeout(() => {
                        this.onScheduledVideoEnd();
                    }, video.duration + 2000);

                    console.log(`üìÖ Playing scheduled video: ${video.filename}`);
                } catch (error) {
                    console.error('‚ùå Error playing scheduled video:', error);
                    this.onScheduledVideoEnd();
                }
            }

            async startSynchronizedBroadcast() {
                const now = Date.now();
                const elapsedSinceEpoch = now - this.epochStart;
                const currentLoopPosition = elapsedSinceEpoch % this.loopDuration;
                const currentSlot = this.loopSchedule[this.currentProgramIndex];
                const slotStartTime = this.epochStart + Math.floor(elapsedSinceEpoch / this.loopDuration) * this.loopDuration + currentSlot.offsetMs;

                if (!currentSlot) {
                    console.error('‚ùå No program slot found');
                    return;
                }

                const timeUntilStart = slotStartTime - now;
                const timeIntoVideo = now - slotStartTime;

                // Only show static and wait if we're MORE than 500ms early
                if (timeUntilStart > 500) {
                    console.log(`üì∫ Static until program starts in ${(timeUntilStart / 1000).toFixed(1)}s`);
                    this.staticElement.classList.add('active', 'temporal-refresh');
                    this.playStaticNoise();

                    await this.preloadScheduledVideo(this.currentProgramIndex);

                    this.scheduledPlayTimeout = setTimeout(() => {
                        this.playScheduledVideo();
                    }, timeUntilStart);
                } else if (timeIntoVideo < 0 || timeIntoVideo < currentSlot.duration) {
                    // Play immediately if we're within 2s of start time OR already in progress
                    const seekTime = Math.max(0, timeIntoVideo / 1000);
                    console.log(`üì∫ Playing video ${seekTime > 0 ? 'at ' + seekTime.toFixed(1) + 's' : 'from start'}`);
                    await this.preloadScheduledVideo(this.currentProgramIndex);
                    await this.playScheduledVideo(seekTime);
                } else {
                    this.currentProgramIndex++;
                    if (this.currentProgramIndex >= this.loopSchedule.length) {
                        this.currentProgramIndex = 0;
                    }
                    await this.startSynchronizedBroadcast();
                }
            }

            async preloadScheduledVideo(programIndex) {
                if (programIndex >= this.loopSchedule.length) return;

                const slot = this.loopSchedule[programIndex];
                const videoPath = `/saved_videos/${slot.filename}`;

                this.currentVideoElement.src = videoPath;
                this.currentVideoElement.volume = this.volume / 100;
                this.currentVideoElement.muted = this.volume === 0;
                this.currentVideoElement.preload = 'auto';
                this.currentVideoElement.load();

                console.log(`üìº Preloading scheduled video: ${slot.filename}`);

                try {
                    await new Promise((resolve, reject) => {
                        const checkReadyToPlay = () => {
                            // Accept readyState >= 3 (HAVE_FUTURE_DATA) for streaming videos
                            if (this.currentVideoElement.readyState >= 3) {
                                console.log(`‚úÖ Scheduled video ready to play (readyState: ${this.currentVideoElement.readyState})`);
                                resolve();
                            }
                        };

                        // Check immediately in case video is already ready
                        if (this.currentVideoElement.readyState >= 3) {
                            console.log(`‚úÖ Video already ready (readyState: ${this.currentVideoElement.readyState})`);
                            resolve();
                            return;
                        }

                        this.currentVideoElement.addEventListener('canplay', checkReadyToPlay, { once: true });
                        this.currentVideoElement.addEventListener('canplaythrough', checkReadyToPlay, { once: true });
                        this.currentVideoElement.addEventListener('error', (e) => {
                            const mediaError = this.currentVideoElement.error;
                            reject(new Error(`Video error code ${mediaError?.code}: ${mediaError?.message || 'Unknown error'} - src: ${this.currentVideoElement.src}`));
                        }, { once: true });

                        // Reduce timeout to 5 seconds for faster channel changes
                        setTimeout(() => {
                            console.log('‚ö†Ô∏è Preload timeout, will play anyway');
                            resolve();
                        }, 5000);
                    });

                    this.isVideoPreloaded = true;
                } catch (error) {
                    console.error('‚ùå Failed to preload scheduled video:', error);
                    this.isVideoPreloaded = false;
                }
            }

            async playScheduledVideo(seekTime = 0) {
                const currentSlot = this.loopSchedule[this.currentProgramIndex];
                const now = Date.now();
                const elapsedSinceEpoch = now - this.epochStart;
                const slotStartTime = this.epochStart + Math.floor(elapsedSinceEpoch / this.loopDuration) * this.loopDuration + currentSlot.offsetMs;
                const actualSeekTime = (now - slotStartTime) / 1000;

                if (!this.isVideoPreloaded) {
                    console.log('‚ö†Ô∏è Video not fully loaded, staying on static');

                    const checkInterval = setInterval(async () => {
                        if (this.isVideoPreloaded) {
                            clearInterval(checkInterval);
                            const newNow = Date.now();
                            const newElapsed = newNow - this.epochStart;
                            const newSlotStart = this.epochStart + Math.floor(newElapsed / this.loopDuration) * this.loopDuration + currentSlot.offsetMs;
                            const newSeekTime = (newNow - newSlotStart) / 1000;

                            if (newSeekTime < currentSlot.duration / 1000) {
                                console.log(`‚úÖ Video loaded, joining at ${newSeekTime.toFixed(1)}s`);
                                await this.playScheduledVideo(newSeekTime);
                            } else {
                                console.log('‚è≠Ô∏è Video took too long to load, skipping to next');
                                this.currentProgramIndex++;
                                this.onScheduledVideoEnd();
                            }
                        }
                    }, 100);

                    setTimeout(() => {
                        if (!this.isVideoPreloaded) {
                            clearInterval(checkInterval);
                            console.log('‚è≠Ô∏è Load timeout, skipping to next');
                            this.currentProgramIndex++;
                            this.onScheduledVideoEnd();
                        }
                    }, 60000);

                    return;
                }

                // Check if video is ready to play (readyState >= 3 for streaming)
                if (this.currentVideoElement.readyState < 3) {
                    console.log(`‚ö†Ô∏è Video not ready (readyState: ${this.currentVideoElement.readyState}), retrying...`);
                    this.isVideoPreloaded = false;
                    setTimeout(() => this.playScheduledVideo(actualSeekTime), 100);
                    return;
                }

                this.staticElement.classList.remove('active', 'temporal-refresh');
                this.stopStaticNoise();

                this.noiseCtx.clearRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);
                this.noiseCtx.fillStyle = '#000000';
                this.noiseCtx.fillRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);

                document.getElementById('currentVideo').style.display = 'block';
                document.getElementById('nextVideo').style.display = 'none';
                document.getElementById('thirdVideo').style.display = 'none';
                document.querySelector('.scan-lines').style.display = 'block';
                document.querySelector('.vignette').style.display = 'block';
                document.querySelector('.logo-overlay').style.display = 'block';

                if (actualSeekTime > 0 && actualSeekTime < currentSlot.duration / 1000) {
                    this.currentVideoElement.currentTime = actualSeekTime;
                    console.log(`‚è© Seeking to ${actualSeekTime.toFixed(1)}s to sync with schedule`);
                }

                await this.currentVideoElement.play();

                document.getElementById('loadingText').style.display = 'none';
                document.getElementById('nowPlaying').style.display = 'block';

                const remainingTime = currentSlot.duration - (actualSeekTime * 1000);

                const endVideo = () => {
                    this.onScheduledVideoEnd();
                };

                this.currentVideoElement.addEventListener('ended', endVideo, { once: true });

                // Use SCHEDULED duration to maintain perfect sync across all clients
                const scheduledEndTimeout = remainingTime;
                setTimeout(endVideo, scheduledEndTimeout);

                // Preload next video BEFORE incrementing index
                const nextIndex = (this.currentProgramIndex + 1) % this.loopSchedule.length;
                await this.preloadScheduledVideo(nextIndex);

                console.log(`üì∫ Playing fully buffered video with ${(remainingTime / 1000).toFixed(1)}s remaining`);
            }

            onScheduledVideoEnd() {
                console.log('üì∫ Loop video ended, checking for scheduled content');

                // ALWAYS stop and mute all videos first
                this.currentVideoElement.pause();
                this.nextVideoElement.pause();
                this.thirdVideoElement.pause();
                this.currentVideoElement.volume = 0;
                this.nextVideoElement.volume = 0;
                this.thirdVideoElement.volume = 0;

                // Hide all video elements completely
                document.getElementById('currentVideo').style.display = 'none';
                document.getElementById('nextVideo').style.display = 'none';
                document.getElementById('thirdVideo').style.display = 'none';

                // Increment index immediately
                this.currentProgramIndex++;
                if (this.currentProgramIndex >= this.loopSchedule.length) {
                    this.currentProgramIndex = 0;
                }

                // 20% chance to show brief static transition for retro TV effect
                if (Math.random() < 0.2) {
                    console.log('üì∫ Random static transition');

                    this.staticElement.classList.add('active', 'temporal-refresh');
                    this.playStaticNoise();

                    setTimeout(() => {
                        this.startHybridBroadcast();
                    }, 2000);
                } else {
                    // Go directly to next content
                    this.startHybridBroadcast();
                }
            }

            getRandomIndex() {
                if (this.videos.length === 0) return -1;

                // Get list of unplayed videos
                const unplayedVideos = this.videos.map((video, index) => ({ video, index }))
                    .filter(item => !this.playedVideos.has(item.video.filename));

                // If all videos have been played, reset the history
                if (unplayedVideos.length === 0) {
                    console.log('üîÑ All videos played, resetting history');
                    this.playedVideos.clear();
                    return Math.floor(Math.random() * this.videos.length);
                }

                // Bias heavily towards unplayed videos (90% chance)
                if (Math.random() < 0.9 && unplayedVideos.length > 0) {
                    // Select from unplayed videos
                    const randomUnplayed = unplayedVideos[Math.floor(Math.random() * unplayedVideos.length)];
                    console.log(`üéØ Selected unplayed video: ${randomUnplayed.video.filename} (${this.playedVideos.size}/${this.videos.length} played)`);
                    return randomUnplayed.index;
                }

                // Fallback to completely random selection
                const randomIndex = Math.floor(Math.random() * this.videos.length);
                console.log(`üé≤ Random fallback selected: ${this.videos[randomIndex].filename} (${this.playedVideos.size}/${this.videos.length} played)`);
                return randomIndex;
            }

            async playRandomVideo() {
                if (this.videos.length === 0) return;

                // Start noise animation
                this.startNoiseAnimation();
                this.staticElement.classList.add('active', 'temporal-refresh');
                this.playStaticNoise();

                // If we have a preloaded video, play it immediately
                if (this.isVideoPreloaded && this.nextIndex !== -1) {
                    this.currentIndex = this.nextIndex;

                    // Track this video as played
                    if (this.currentIndex >= 0 && this.currentIndex < this.videos.length) {
                        this.playedVideos.add(this.videos[this.currentIndex].filename);
                    }

                    this.nextIndex = this.thirdIndex;
                    this.thirdIndex = -1;
                    this.isVideoPreloaded = this.isThirdVideoPreloaded;
                    this.isThirdVideoPreloaded = false;

                    this.rotateVideoElements();

                    // HIDE STATIC immediately since we have a preloaded video ready
                    this.staticElement.classList.remove('active', 'temporal-refresh');
                    this.stopStaticNoise();
                    // Keep animation running for smooth transitions

                    // Clear the canvas completely to ensure static is hidden
                    this.noiseCtx.clearRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);

                    // Restore ONLY necessary video elements
                    document.getElementById('currentVideo').style.display = 'block';
                    document.getElementById('nextVideo').style.display = 'none';
                    document.getElementById('thirdVideo').style.display = 'none';
                    document.querySelector('.scan-lines').style.display = 'block';
                    document.querySelector('.vignette').style.display = 'block';
                    document.querySelector('.logo-overlay').style.display = 'block';

                    // Start playing the video immediately after static is cleared
                    this.currentVideoElement.play();

                    // Preload next videos in background without showing static
                    this.preloadNextVideoSequential();

                    console.log('üì∫ Video playing from preloaded source - static completely cleared');
                    return;
                }

                // If no preloaded video, load one and show static until fully loaded
                this.currentIndex = this.getRandomIndex();

                // Track this video as played
                if (this.currentIndex >= 0 && this.currentIndex < this.videos.length) {
                    this.playedVideos.add(this.videos[this.currentIndex].filename);
                }

                const video = this.videos[this.currentIndex];
                const videoPath = `/saved_videos/${video.filename}`;

                this.currentVideoElement.src = videoPath;
                this.currentVideoElement.volume = this.volume / 100;
                this.currentVideoElement.muted = this.volume === 0;

                try {
                    // Wait for entire video to be fully buffered before playing
                    await new Promise((resolve, reject) => {
                        const checkFullyBuffered = () => {
                            if (this.currentVideoElement.readyState === 4) {
                                // HAVE_ENOUGH_DATA: entire video is buffered
                                const buffered = this.currentVideoElement.buffered;
                                if (buffered.length > 0) {
                                    const bufferedEnd = buffered.end(buffered.length - 1);
                                    const duration = this.currentVideoElement.duration;

                                    if (bufferedEnd >= duration - 0.5 || this.currentVideoElement.readyState === 4) {
                                        console.log(`üìº Video fully buffered: ${bufferedEnd.toFixed(1)}s / ${duration.toFixed(1)}s`);
                                        resolve();
                                    }
                                }
                            }
                        };

                        this.currentVideoElement.addEventListener('canplaythrough', checkFullyBuffered, { once: true });
                        this.currentVideoElement.addEventListener('progress', checkFullyBuffered);
                        this.currentVideoElement.addEventListener('error', (e) => {
                            const mediaError = this.currentVideoElement.error;
                            reject(new Error(`Video buffer error code ${mediaError?.code}: ${mediaError?.message || 'Unknown error'} - src: ${this.currentVideoElement.src}`));
                        }, { once: true });

                        // Fallback timeout
                        setTimeout(() => {
                            console.log('‚ö†Ô∏è Buffer timeout, playing anyway');
                            resolve();
                        }, 15000);
                    });

                    // Hide static now that video is fully buffered
                    this.staticElement.classList.remove('active', 'temporal-refresh');
                    this.stopStaticNoise();

                    // Clear the canvas
                    this.noiseCtx.clearRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);
                    this.noiseCtx.fillStyle = '#000000';
                    this.noiseCtx.fillRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);

                    // Restore video elements
                    document.getElementById('currentVideo').style.display = 'block';
                    document.getElementById('nextVideo').style.display = 'none';
                    document.getElementById('thirdVideo').style.display = 'none';
                    document.querySelector('.scan-lines').style.display = 'block';
                    document.querySelector('.vignette').style.display = 'block';
                    document.querySelector('.logo-overlay').style.display = 'block';

                    // Now play the fully buffered video
                    await this.currentVideoElement.play();

                    document.getElementById('loadingText').style.display = 'none';
                    document.getElementById('nowPlaying').style.display = 'block';

                    // Start preloading next videos in background without showing static
                    this.preloadNextVideoSequential();
                } catch (error) {
                    console.error('‚ùå Error playing video:', error);
                    document.getElementById('loadingText').textContent = 'PLAYBACK ERROR';
                    this.stopNoiseAnimation();
                }
            }

            async preloadNextVideo() {
                this.nextIndex = this.getRandomIndex();
                if (this.nextIndex === -1) return;

                const nextVideo = this.videos[this.nextIndex];
                const nextVideoPath = `/saved_videos/${nextVideo.filename}`;

                // Set up enhanced preloading for smooth playback
                this.nextVideoElement.src = nextVideoPath;
                this.nextVideoElement.volume = this.volume / 100;
                this.nextVideoElement.muted = this.volume === 0;
                this.nextVideoElement.preload = 'auto';
                this.nextVideoElement.load();

                // Wait for enough data to play smoothly
                try {
                    await new Promise((resolve, reject) => {
                        this.nextVideoElement.addEventListener('loadeddata', () => {
                            this.isVideoPreloaded = true;
                            console.log(`üìº Preloaded next video (enough data): ${nextVideo.filename}`);
                            resolve();
                        }, { once: true });
                        this.nextVideoElement.addEventListener('error', reject, { once: true });

                        // Fallback timeout
                        setTimeout(() => {
                            this.isVideoPreloaded = true;
                            console.log(`‚ö†Ô∏è Preload for ${nextVideo.filename} completed with timeout`);
                            resolve();
                        }, 5000);
                    });
                } catch (error) {
                    console.log(`‚ùå Preload failed for ${nextVideo.filename}:`, error);
                    this.isVideoPreloaded = false;
                }
            }

            async preloadThirdVideo() {
                this.thirdIndex = this.getRandomIndex();
                if (this.thirdIndex === -1) return;

                const thirdVideo = this.videos[this.thirdIndex];
                const thirdVideoPath = `/saved_videos/${thirdVideo.filename}`;

                // Set up enhanced preloading for smooth playback
                this.thirdVideoElement.src = thirdVideoPath;
                this.thirdVideoElement.volume = this.volume / 100;
                this.thirdVideoElement.muted = this.volume === 0;
                this.thirdVideoElement.preload = 'auto';
                this.thirdVideoElement.load();

                // Wait for enough data to play smoothly
                try {
                    await new Promise((resolve, reject) => {
                        this.thirdVideoElement.addEventListener('loadeddata', () => {
                            this.isThirdVideoPreloaded = true;
                            console.log(`üìº Preloaded third video (enough data): ${thirdVideo.filename}`);
                            resolve();
                        }, { once: true });
                        this.thirdVideoElement.addEventListener('error', reject, { once: true });

                        // Fallback timeout
                        setTimeout(() => {
                            this.isThirdVideoPreloaded = true;
                            console.log(`‚ö†Ô∏è Third preload for ${thirdVideo.filename} completed with timeout`);
                            resolve();
                        }, 5000);
                    });
                } catch (error) {
                    console.log(`‚ùå Third preload failed for ${thirdVideo.filename}:`, error);
                    this.isThirdVideoPreloaded = false;
                }
            }

            async preloadNextVideoSequential() {
                // Preload next video first, then third video sequentially
                await this.preloadNextVideo();

                // Only preload third if next was successful
                if (this.isVideoPreloaded) {
                    await this.preloadThirdVideo();
                }
            }

            rotateVideoElements() {
                // Move next video to current, third to next, and clear third
                this.currentVideoElement.src = this.nextVideoElement.src;
                this.currentVideoElement.volume = this.nextVideoElement.volume;
                this.currentVideoElement.muted = this.nextVideoElement.muted;

                this.nextVideoElement.src = this.thirdVideoElement.src;
                this.nextVideoElement.volume = this.thirdVideoElement.volume;
                this.nextVideoElement.muted = this.thirdVideoElement.muted;

                // Clear third video element
                this.thirdVideoElement.src = '';
                this.thirdVideoElement.volume = 0;
                this.thirdVideoElement.muted = true;

                this.currentVideoElement.style.display = 'block';
                this.nextVideoElement.style.display = 'none';
                this.thirdVideoElement.style.display = 'none';
            }

            swapVideoElements() {
                const tempSrc = this.currentVideoElement.src;
                this.currentVideoElement.src = this.nextVideoElement.src;
                this.nextVideoElement.src = tempSrc;

                this.currentVideoElement.style.display = 'block';
                this.nextVideoElement.style.display = 'none';
            }

            setupVolumeControl() {
                const knob = document.getElementById('volumeKnob');
                const indicator = document.getElementById('volumeIndicator');
                const level = document.getElementById('volumeLevel');

                const updateVolume = (angle) => {
                    this.volume = Math.round(Math.max(0, Math.min(100, angle)));
                    indicator.style.transform = `translate(-50%, -50%) rotate(${this.volume * 2.7 - 135}deg)`;
                    level.textContent = this.volume;

                    this.currentVideoElement.volume = this.volume / 100;
                    this.currentVideoElement.muted = this.volume === 0;

                    // Update static noise volume to match TV volume and mute when needed
                    if (this.gainNode) {
                        if (this.volume === 0) {
                            this.gainNode.gain.value = 0; // Completely mute static when volume is 0
                        } else {
                            const staticVolume = Math.min(0.3, this.volume / 200);
                            this.gainNode.gain.value = staticVolume;
                        }
                    }

                    // Update atmospheric audio volume to match TV volume
                    this.updateAtmosphericVolume();

                    // Play loud crackle when volume changes
                    this.playVolumeCrackle();
                };

                const handleMouseDown = (e) => {
                    this.isDragging = true;
                    e.preventDefault();
                };

                const handleMouseMove = (e) => {
                    if (!this.isDragging) return;

                    const rect = knob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    const degrees = (angle * 180 / Math.PI + 90 + 360) % 360;
                    updateVolume(degrees);
                };

                const handleMouseUp = () => {
                    this.isDragging = false;
                };

                knob.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                knob.addEventListener('touchstart', (e) => {
                    this.isDragging = true;
                    e.preventDefault();
                });

                knob.addEventListener('touchmove', (e) => {
                    if (!this.isDragging) return;
                    const touch = e.touches[0];
                    const rect = knob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const angle = Math.atan2(touch.clientY - centerY, touch.clientX - centerX);
                    const degrees = (angle * 180 / Math.PI + 90 + 360) % 360;
                    updateVolume(degrees);
                });

                knob.addEventListener('touchend', () => {
                    this.isDragging = false;
                });

                updateVolume(0);
            }

            setupAudioInteraction() {
                // Set up user interaction to enable audio
                const enableAudio = () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    // Create static noise on first interaction
                    if (!this.whiteNoiseBuffer) {
                        this.createStaticNoise();
                        // Initialize atmospheric audio volume after creation
                        this.updateAtmosphericVolume();
                    }
                    // Ensure crackle noise is ready
                    if (!this.crackleNoiseBuffer) {
                        this.createCrackleNoise();
                    }
                };

                // Add click listener to document for audio enable
                document.addEventListener('click', enableAudio, { once: true });

                // Also enable on any key press
                document.addEventListener('keydown', enableAudio, { once: true });
            }

            showStaticBetweenVideos() {
                console.log('üì∫ Showing static between videos...');

                // Hide ALL non-static elements for maximum performance
                document.getElementById('currentVideo').style.display = 'none';
                document.getElementById('nextVideo').style.display = 'none';
                document.getElementById('thirdVideo').style.display = 'none';
                document.getElementById('loadingText').style.display = 'none';
                document.getElementById('nowPlaying').style.display = 'none';
                document.querySelector('.scan-lines').style.display = 'none';
                document.querySelector('.vignette').style.display = 'none';
                document.querySelector('.logo-overlay').style.display = 'none';

                // Stop all videos to prevent them from processing
                this.currentVideoElement.pause();
                this.nextVideoElement.pause();
                this.thirdVideoElement.pause();

                // Show static with maximum performance (don't restart animation if already running)
                if (!this.noiseAnimationId) {
                    this.startNoiseAnimation();
                }
                this.staticElement.classList.add('active', 'temporal-refresh');
                this.playStaticNoise();

                // Wait at least 2 seconds for static effect, then play next video
                setTimeout(() => {
                    this.playRandomVideo();
                }, 2000);
            }

            // Canvas noise functionality
            initNoiseCanvas() {
                // Set canvas to lower resolution for better performance
                const rect = this.noiseCanvas.getBoundingClientRect();
                this.noiseCanvas.width = Math.floor(rect.width / 7.5); // 2x higher resolution
                this.noiseCanvas.height = Math.floor(rect.height / 7.5);

                // Enable high-quality image smoothing for better upscaling
                this.noiseCtx.imageSmoothingEnabled = true;
                this.noiseCtx.imageSmoothingQuality = 'high'; // Best quality upscaling

                // CSS blur applied to .tv-static element instead

                // Pre-fill canvas with black before first noise generation
                this.noiseCtx.fillStyle = '#000000';
                this.noiseCtx.fillRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);
            }

            generateRandomNoise() {
                const width = this.noiseCanvas.width;
                const height = this.noiseCanvas.height;

                // Create ImageData for direct pixel manipulation (more efficient)
                const imageData = this.noiseCtx.createImageData(width, height);
                const data = imageData.data;

                // Generate noise directly in pixel array for better performance
                for (let i = 0; i < data.length; i += 4) {
                    if (Math.random() > 0.3) { // 70% chance for static
                        const value = Math.random() * 255;
                        data[i] = value;     // Red
                        data[i + 1] = value * 0.9; // Green
                        data[i + 2] = value * 0.8; // Blue
                        data[i + 3] = 255;   // Alpha (fully opaque)
                    } else {
                        data[i] = 0;     // Red
                        data[i + 1] = 0; // Green
                        data[i + 2] = 0; // Blue
                        data[i + 3] = 255; // Alpha (fully opaque)
                    }
                }

                // Put the ImageData back to canvas in one operation
                this.noiseCtx.putImageData(imageData, 0, 0);
            }

            startNoiseAnimation() {
                // Target realistic 30fps for smooth static with good performance
                const targetFPS = 25; // Slightly lower FPS for higher quality static
                const frameInterval = 1000 / targetFPS; // ~33ms per frame
                let then = performance.now();

                const animate = (currentTime) => {
                    const elapsed = currentTime - then;

                    // Only render if enough time has passed for target framerate
                    if (elapsed > frameInterval) {
                        then = currentTime - (elapsed % frameInterval);
                        this.generateRandomNoise();
                    }

                    this.noiseAnimationId = requestAnimationFrame(animate);
                };
                this.noiseAnimationId = requestAnimationFrame(animate);
            }

            stopNoiseAnimation() {
                if (this.noiseAnimationId) {
                    cancelAnimationFrame(this.noiseAnimationId);
                    this.noiseAnimationId = null;
                }
            }

            // Audio noise functionality
            initAudioNoise() {
                // Create procedural static noise using Web Audio API
                this.audioContext = null;
                this.staticNoiseSource = null;
                this.gainNode = null;
            }

            createStaticNoise() {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    // Create white noise using buffer approach
                    const bufferSize = this.audioContext.sampleRate * 2; // 2 seconds of noise
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1; // White noise between -1 and 1
                    }

                    // Create buffer source for continuous noise
                    this.whiteNoiseBuffer = buffer;

                    // Create gain node for volume control
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 0; // Start silent

                    // Create filter for TV static sound
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 1000;
                    filter.Q.value = 1;

                    // Create atmospheric audio effects
                    this.createAtmosphericAudio();

                    // Connect the audio nodes
                    filter.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);

                    this.filterNode = filter;
                    console.log('‚úÖ Static noise audio created with atmospheric effects');
                } catch (error) {
                    console.log('‚ùå Error creating static noise:', error.message);
                }
            }

            createAtmosphericAudio() {
                // Create high-pitched whine (8-12kHz range) with enhanced modulation
                this.whineOscillator = this.audioContext.createOscillator();
                this.whineGain = this.audioContext.createGain();
                this.whineLFO = this.audioContext.createOscillator();
                this.whineLFODepth = this.audioContext.createGain();

                this.whineOscillator.type = 'sine';
                this.whineOscillator.frequency.value = 10000; // 10kHz whine
                this.whineGain.gain.value = 0; // Start silent

                // Add LFO for subtle frequency modulation to create more dynamic whine
                this.whineLFO.type = 'triangle';
                this.whineLFO.frequency.value = 0.2; // Very slow modulation
                this.whineLFODepth.gain.value = 200; // ¬±200Hz variation
                this.whineLFO.connect(this.whineLFODepth);
                this.whineLFODepth.connect(this.whineOscillator.frequency);
                this.whineLFO.start();

                // Create fat hum (60Hz with harmonics) and additional oscillators
                this.humOscillator = this.audioContext.createOscillator();
                this.humGain = this.audioContext.createGain();
                this.humFilter = this.audioContext.createBiquadFilter();
                this.humOscillator2 = this.audioContext.createOscillator(); // Second hum for richness
                this.humGain2 = this.audioContext.createGain();

                this.humOscillator.type = 'sawtooth'; // Rich harmonics for fat sound
                this.humOscillator.frequency.value = 60; // 60Hz hum
                this.humFilter.type = 'lowpass';
                this.humFilter.frequency.value = 200; // Low-pass to create mellow hum
                this.humFilter.Q.value = 0.5;
                this.humGain.gain.value = 0; // Start silent

                this.humOscillator2.type = 'square'; // Different waveform for complexity
                this.humOscillator2.frequency.value = 120; // First harmonic of 60Hz
                this.humGain2.gain.value = 0; // Start silent

                // Create enhanced volume crackle effect with multiple noise sources
                this.crackleGain = this.audioContext.createGain();
                this.crackleFilter = this.audioContext.createBiquadFilter();
                this.crackleFilter2 = this.audioContext.createBiquadFilter();
                this.crackleFilter3 = this.audioContext.createBiquadFilter();
                this.crackleNoiseBuffer = null;
                this.crackleSource = null;
                this.staticCrackleBuffer = null;
                this.staticCrackleSource = null;

                // Enhanced SHARP filters for piercing crackle sound
                this.crackleFilter.type = 'bandpass';
                this.crackleFilter.frequency.value = 7000;
                this.crackleFilter.Q.value = 3.0;

                this.crackleFilter2.type = 'highpass';
                this.crackleFilter2.frequency.value = 8000;
                this.crackleFilter2.Q.value = 5.0;

                this.crackleFilter3.type = 'highpass';
                this.crackleFilter3.frequency.value = 10000;
                this.crackleFilter3.Q.value = 8.0;

                this.crackleGain.gain.value = 0; // Start silent

                this.createCrackleNoise();
                this.createStaticCrackle();

                // Connect hum through filter
                this.humOscillator.connect(this.humFilter);
                this.humFilter.connect(this.humGain);

                // Connect second hum directly with lower volume
                this.humOscillator2.connect(this.humGain2);

                // Connect whine directly
                this.whineOscillator.connect(this.whineGain);

                // Connect crackle through THREE filters for ULTRA SHARP sound
                this.crackleFilter.connect(this.crackleGain);
                this.crackleFilter2.connect(this.crackleGain);
                this.crackleFilter3.connect(this.crackleGain);

                // Start oscillators (they'll be silent until gain is adjusted)
                this.whineOscillator.start();
                this.humOscillator.start();
                this.humOscillator2.start();

                // Connect atmospheric audio to destination
                this.whineGain.connect(this.audioContext.destination);
                this.humGain.connect(this.audioContext.destination);
                this.humGain2.connect(this.audioContext.destination);
                this.crackleGain.connect(this.audioContext.destination);

                console.log('‚úÖ Enhanced atmospheric audio created (whine, dual hum, and crackle)');
            }

            createCrackleNoise() {
                // Create SHARP, QUICK, LOUD, RANDOM crackle effect
                const bufferSize = this.audioContext.sampleRate * 0.08; // 0.08 seconds - much quicker
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    // EXTREMELY random static pattern
                    const randomFactor = Math.random();
                    if (randomFactor > 0.15) { // 85% chance for static (more random)
                        // Ultra-sharp, completely random crackles
                        const staticType = Math.random();
                        if (staticType > 0.85) {
                            // PIERCING spike crackle - SHARP and LOUD
                            output[i] = (Math.random() * 2 - 1) * (Math.random() > 0.7 ? 5.0 : 4.0);
                        } else if (staticType > 0.6) {
                            // Sharp crackle
                            output[i] = (Math.random() * 2 - 1) * (Math.random() > 0.5 ? 3.0 : 2.0);
                        } else if (staticType > 0.35) {
                            // Medium crackle
                            output[i] = (Math.random() * 2 - 1) * (Math.random() > 0.4 ? 1.5 : 1.0);
                        } else {
                            // Quick hiss
                            output[i] = (Math.random() * 2 - 1) * 0.4;
                        }
                    } else {
                        // Random silence or micro-noise
                        output[i] = (Math.random() > 0.8 ? (Math.random() * 2 - 1) * 0.05 : 0);
                    }
                }

                this.crackleNoiseBuffer = buffer;
                console.log('‚ö°üîä Created SHARP, QUICK, LOUD, RANDOM crackle buffer');
            }

            playVolumeCrackle() {
                if (!this.audioContext || !this.crackleNoiseBuffer) return;

                // Stop existing crackle
                if (this.crackleSource) {
                    try {
                        this.crackleSource.stop();
                    } catch (e) {}
                }

                // Create new crackle source
                this.crackleSource = this.audioContext.createBufferSource();
                this.crackleSource.buffer = this.crackleNoiseBuffer;
                // Connect through ALL THREE filters for ULTRA SHARP texture
                this.crackleSource.connect(this.crackleFilter);
                this.crackleSource.connect(this.crackleFilter2);
                this.crackleSource.connect(this.crackleFilter3);

                // ULTRA LOUD CRACKLE - MAXIMUM volume
                const crackleVolume = Math.max(1.2, Math.min(2.5, this.volume / 20)); // Always at least 120% volume, can go to 250%
                this.crackleGain.gain.setValueAtTime(crackleVolume, this.audioContext.currentTime);
                this.crackleGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05); // QUICK fade

                this.crackleSource.start();
                this.crackleSource.stop(this.audioContext.currentTime + 0.05); // VERY QUICK duration

                console.log(`‚ö°üîä‚ö° ULTRA SHARP CRACKLE at volume: ${crackleVolume.toFixed(2)}`);
            }

            createStaticCrackle() {
                // Create additional static-based crackle for more texture
                const bufferSize = this.audioContext.sampleRate * 0.15; // 0.15 seconds
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    // More varied static pattern
                    const randomFactor = Math.random();
                    if (randomFactor > 0.7) {
                        // Occasional louder static burst
                        output[i] = (Math.random() * 2 - 1) * 1.5;
                    } else if (randomFactor > 0.4) {
                        // Medium static
                        output[i] = (Math.random() * 2 - 1) * 0.8;
                    } else {
                        // Light static or silence
                        output[i] = (Math.random() * 2 - 1) * 0.2;
                    }
                }

                this.staticCrackleBuffer = buffer;
                console.log('‚úÖ Created static crackle buffer');
            }

            updateAtmosphericVolume() {
                if (this.volume === 0) {
                    // Mute all atmospheric audio when volume is 0
                    if (this.whineGain) this.whineGain.gain.value = 0;
                    if (this.humGain) this.humGain.gain.value = 0;
                    if (this.humGain2) this.humGain2.gain.value = 0;
                } else {
                    // Set atmospheric audio volume based on TV volume (very subtle)
                    const whineVolume = Math.min(0.02, this.volume / 5000); // Very soft whine
                    const humVolume = Math.min(0.025, this.volume / 4000);  // Main hum
                    const hum2Volume = Math.min(0.015, this.volume / 6000); // Secondary hum

                    if (this.whineGain) this.whineGain.gain.value = whineVolume;
                    if (this.humGain) this.humGain.gain.value = humVolume;
                    if (this.humGain2) this.humGain2.gain.value = hum2Volume;
                }
            }

            playStaticNoise() {
                try {
                    if (!this.audioContext || !this.whiteNoiseBuffer) {
                        this.createStaticNoise();
                    }

                    // Resume audio context if suspended (required by some browsers)
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }

                    // Stop any existing noise source
                    this.stopStaticNoise();

                    // Create and start new buffer source
                    this.staticNoiseSource = this.audioContext.createBufferSource();
                    this.staticNoiseSource.buffer = this.whiteNoiseBuffer;
                    this.staticNoiseSource.loop = true;
                    this.staticNoiseSource.connect(this.filterNode);

                    // Adjust static noise volume based on TV volume and mute when needed
                    if (this.gainNode) {
                        if (this.volume === 0) {
                            this.gainNode.gain.value = 0; // Completely mute static when volume is 0
                        } else {
                            const staticVolume = Math.min(0.3, this.volume / 200);
                            this.gainNode.gain.value = staticVolume;
                        }
                    }

                    // Start playing
                    this.staticNoiseSource.start(0);
                    console.log('üîä Static noise started');
                } catch (error) {
                    console.log('‚ùå Error playing static noise:', error.message);
                }
            }

            stopStaticNoise() {
                try {
                    if (this.gainNode) {
                        this.gainNode.gain.value = 0;
                    }

                    // Stop and disconnect the buffer source
                    if (this.staticNoiseSource) {
                        try {
                            this.staticNoiseSource.stop();
                            this.staticNoiseSource.disconnect();
                        } catch (e) {
                            // Source might already be stopped
                        }
                        this.staticNoiseSource = null;
                    }

                    console.log('üîá Static noise stopped');
                } catch (error) {
                    console.log('Error stopping static noise:', error.message);
                }
            }

            toggleFullscreen() {
                const tvContainer = document.querySelector('.tv-container');
                const fullscreenBtn = document.getElementById('fullscreenToggle');
                const icon = fullscreenBtn.querySelector('i');
                const fullscreenHint = document.getElementById('fullscreenHint');

                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    tvContainer.requestFullscreen().then(() => {
                        icon.classList.remove('fa-expand');
                        icon.classList.add('fa-compress');
                        fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> EXIT FULLSCREEN';
                        console.log('üì∫ Entered fullscreen mode');

                        // Show exit hint
                        fullscreenHint.style.display = 'block';
                        setTimeout(() => {
                            fullscreenHint.style.display = 'none';
                        }, 3000);
                    }).catch((err) => {
                        console.error('Error attempting to enable fullscreen:', err);
                    });
                } else {
                    // Exit fullscreen
                    document.exitFullscreen().then(() => {
                        icon.classList.remove('fa-compress');
                        icon.classList.add('fa-expand');
                        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> FULLSCREEN';
                        console.log('üì∫ Exited fullscreen mode');
                        fullscreenHint.style.display = 'none';
                    }).catch((err) => {
                        console.error('Error attempting to exit fullscreen:', err);
                    });
                }
            }

            setupEventListeners() {
                this.currentVideoElement.addEventListener('ended', () => {
                    // Always show static between videos, even with preloading
                    this.showStaticBetweenVideos();
                });

                this.currentVideoElement.addEventListener('error', (e) => {
                    const mediaError = this.currentVideoElement.error;
                    const errorDetails = {
                        code: mediaError?.code,
                        message: mediaError?.message,
                        src: this.currentVideoElement.src,
                        readyState: this.currentVideoElement.readyState,
                        networkState: this.currentVideoElement.networkState
                    };
                    console.error('‚ùå Video error:', errorDetails);
                    setTimeout(() => this.playRandomVideo(), 2000);
                });

                // All control event listeners removed for clean viewing experience
            }
        }

        // Load shared navbar
        const navbarScript = document.createElement('script');
        navbarScript.src = '/components/navbar.js';
        navbarScript.onload = () => {
            const navbar = new SharedNavbar();
            navbar.inject();
        };
        document.head.appendChild(navbarScript);

        document.addEventListener('DOMContentLoaded', async () => {
            const tv = new Schwelevision();
            await tv.init();
        });
    </script>
</body>
</html>
