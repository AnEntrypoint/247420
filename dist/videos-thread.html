<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>247420 - Digital Dive Bar Videos üçª | TV Room</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">

    <!-- SEO Meta Tags -->
    <meta name="description" content="247420 Digital Dive Bar TV Room - Where drunk hackers and meme culturists gather to watch chaotic broadcasts. Featuring questionable content, late-night programming, and bar regulars on screen.">
    <meta name="keywords" content="247420 digital dive bar, tv room, drunk hackers, meme culturists, chaotic broadcasts, bar television, late night programming, questionable content">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://247420.247247420.xyz/videos-thread.html">

    <!-- Open Graph Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://247420.247247420.xyz/videos-thread.html">
    <meta property="og:title" content="247420 | Digital Dive Bar TV Room üçª">
    <meta property="og:description" content="Where drunk hackers and meme culturists gather to watch chaotic broadcasts and questionable late-night programming.">
    <meta property="og:image" content="https://247420.247247420.xyz/logo.gif">
    <meta property="og:site_name" content="247420 Digital Dive Bar">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="247420 | Digital Dive Bar TV Room üçª">
    <meta name="twitter:description" content="Where drunk hackers and meme culturists gather to watch chaotic broadcasts.">
    <meta name="twitter:image" content="https://247420.247247420.xyz/logo.gif">

    <link href="https://fonts.googleapis.com/css2?family=VT323:wght@400;700&family=Share+Tech+Mono&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Digital Dive Bar Theme Variables */
        :root {
            --dive-bar-bg: #1a1a1a;
            --dive-bar-dark: #0d0d0d;
            --beer-foam: #f5e6d3;
            --dirty-wall: #2d2d2d;
            --neon-sign: #ff6b35;
            --neon-blue: #00d4ff;
            --spilled-beer: #8b6914;
            --graffiti-red: #ff1744;
            --terminal-green: #00ff41;
            --urine-stain: #c4b000;
            --rust-metal: #8b4513;
            --bar-stool: #4a3c28;
            --vomit-green: #7a8c3a;
            --dark-wood: #3e2723;
            --smoke-haze: rgba(255, 255, 255, 0.05);
            --beer-glass: rgba(255, 250, 240, 0.1);

            /* Terminal Colors (kept for compatibility) */
            --terminal-bg: var(--dive-bar-bg);
            --terminal-green: var(--terminal-green);
            --terminal-green-bright: var(--neon-sign);
            --terminal-amber: var(--spilled-beer);
            --terminal-red: var(--graffiti-red);
            --terminal-blue: var(--neon-blue);
            --text-primary: var(--beer-foam);
            --text-secondary: var(--beer-foam);
            --text-dim: var(--rust-metal);
            --border-color: var(--dirty-wall);
            --cursor-color: var(--terminal-green);
            --terminal-bg-alt: var(--dive-bar-dark);
            --terminal-border: var(--rust-metal);

            /* TV specific colors */
            --tv-bezel: var(--dark-wood);
            --tv-screen: var(--dive-bar-dark);
            --border: var(--rust-metal);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'VT323', 'Share Tech Mono', 'Press Start 2P', 'JetBrains Mono', monospace;
            background:
                radial-gradient(circle at 20% 80%, rgba(255, 107, 53, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(139, 105, 20, 0.08) 0%, transparent 50%),
                linear-gradient(135deg, var(--dive-bar-bg) 0%, var(--dive-bar-dark) 100%);
            color: var(--beer-foam);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        /* Import Dive Bar Fonts */
        /* Beer Stain Overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse at 10% 20%, rgba(139, 105, 20, 0.12) 0%, transparent 40%),
                radial-gradient(ellipse at 90% 80%, rgba(196, 0, 0, 0.08) 0%, transparent 30%),
                radial-gradient(ellipse at 50% 50%, rgba(255, 107, 53, 0.05) 0%, transparent 60%);
            pointer-events: none;
            z-index: 1;
        }
        .terminal-scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: repeating-linear-gradient(
                0deg,
                rgba(255, 107, 53, 0.03),
                rgba(255, 107, 53, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
        }
        .terminal-flicker {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: var(--dive-bar-bg);
            animation: diveBarFlicker 0.2s infinite;
            pointer-events: none;
        }
        @keyframes diveBarFlicker {
            0% { opacity: 0.96; }
            25% { opacity: 1; }
            50% { opacity: 0.98; }
            75% { opacity: 0.97; }
            100% { opacity: 0.99; }
        }
        /* Beer Spill Drip Animation */
        @keyframes beerDrip {
            0% { transform: translateY(-10px); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
        .beer-drip {
            position: fixed;
            top: -10px;
            width: 3px;
            height: 20px;
            background: linear-gradient(to bottom, var(--beer-foam), var(--spilled-beer));
            border-radius: 50%;
            animation: beerDrip 8s infinite;
            pointer-events: none;
            z-index: 1000;
        }
        .beer-drip:nth-child(1) { left: 10%; animation-delay: 0s; }
        .beer-drip:nth-child(2) { left: 30%; animation-delay: 2s; }
        .beer-drip:nth-child(3) { left: 50%; animation-delay: 4s; }
        .beer-drip:nth-child(4) { left: 70%; animation-delay: 6s; }
        .beer-drip:nth-child(5) { left: 90%; animation-delay: 1s; }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .hero-section {
            text-align: center;
            padding: 140px 0 80px;
            position: relative;
        }
        .hero-title {
            font-size: 3.5rem;
            color: var(--neon-sign);
            margin-bottom: 20px;
            text-shadow:
                0 0 10px var(--neon-sign),
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 107, 53, 0.5);
            line-height: 1.1;
            font-weight: 700;
            font-family: 'Press Start 2P', 'VT323', monospace;
            animation: titleGlitch 4s ease-in-out infinite;
        }
        @keyframes titleGlitch {
            0%, 90%, 100% {
                transform: translate(0);
                filter: hue-rotate(0deg) brightness(1);
                text-shadow: 0 0 10px var(--neon-sign), 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 20px rgba(255, 107, 53, 0.5);
            }
            91% {
                transform: translate(-2px, 2px);
                filter: hue-rotate(90deg) brightness(1.2);
                text-shadow: 2px 2px 0 var(--graffiti-red), -2px -2px 0 var(--neon-blue);
            }
            92% {
                transform: translate(2px, -2px);
                filter: hue-rotate(180deg) brightness(0.8);
                text-shadow: -2px 2px 0 var(--terminal-green), 2px -2px 0 var(--urine-stain);
            }
            93% {
                transform: translate(-1px, 1px);
                filter: hue-rotate(270deg) brightness(1.1);
                text-shadow: 1px -1px 0 var(--neon-blue), -1px 1px 0 var(--spilled-beer);
            }
        }
        .hero-subtitle {
            font-size: 1.4rem;
            color: var(--beer-foam);
            margin-bottom: 40px;
            font-weight: 400;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            animation: subtitleFlicker 3s ease-in-out infinite;
        }
        @keyframes subtitleFlicker {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
            75% { opacity: 0.95; }
        }
        /* Dive Bar Navigation Styles */
        .navbar {
            background: linear-gradient(135deg, var(--dive-bar-dark), var(--dirty-wall));
            border: 2px solid var(--neon-sign);
            border-radius: 15px;
            padding: 15px 25px;
            margin: 20px auto;
            max-width: 900px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            box-shadow:
                0 8px 32px rgba(255, 107, 53, 0.3),
                0 0 20px rgba(0, 212, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            animation: navGlow 3s ease-in-out infinite;
        }
        @keyframes navGlow {
            0%, 100% { box-shadow: 0 8px 32px rgba(255, 107, 53, 0.3), 0 0 20px rgba(0, 212, 255, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1); }
            50% { box-shadow: 0 12px 40px rgba(255, 107, 53, 0.5), 0 0 30px rgba(0, 212, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2); }
        }
        .navbar a {
            color: var(--beer-foam);
            text-decoration: none;
            font-weight: 600;
            padding: 10px 18px;
            border-radius: 10px;
            transition: all 0.4s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            border: 1px solid var(--rust-metal);
            background: rgba(139, 69, 19, 0.2);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            animation: navBounce 3s ease-in-out infinite;
        }
        @keyframes navBounce {
            0%, 80%, 100% { transform: translateY(0); }
            85% { transform: translateY(-2px); }
            90% { transform: translateY(-1px); }
            95% { transform: translateY(-1.5px); }
        }
        .navbar a:nth-child(odd) { animation-delay: 0.1s; }
        .navbar a:nth-child(even) { animation-delay: 0.2s; }
        .navbar a:hover {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.3), rgba(0, 212, 255, 0.2));
            color: var(--neon-sign);
            border: 2px solid var(--neon-blue);
            box-shadow:
                0 0 15px rgba(255, 107, 53, 0.6),
                0 0 25px rgba(0, 212, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-2px) scale(1.05);
            animation: none;
        }
        .navbar a.active {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.4), rgba(0, 212, 255, 0.3));
            color: var(--neon-sign);
            border: 2px solid var(--neon-blue);
            box-shadow:
                0 0 20px rgba(255, 107, 53, 0.8),
                0 0 30px rgba(0, 212, 255, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            animation: none;
        }
        .navbar i {
            font-size: 16px;
            color: var(--neon-sign);
            animation: iconGlow 2s ease-in-out infinite;
        }
        @keyframes iconGlow {
            0%, 100% { text-shadow: 0 0 5px var(--neon-sign); }
            50% { text-shadow: 0 0 15px var(--neon-sign), 0 0 25px var(--neon-blue); }
        }
        .tv-container {
            position: relative;
            max-width: 900px;
            width: 100%;
            margin: 40px auto;
            padding: 52px 197px 13px 196px;
            background: linear-gradient(135deg, var(--dark-wood), var(--dive-bar-dark));
            border: 2px solid var(--neon-sign);
            border-radius: 30px;
            filter: drop-shadow(0 0 30px rgba(255, 107, 53, 0.3));
            box-shadow:
                0 8px 32px rgba(255, 107, 53, 0.2),
                0 0 20px rgba(0, 212, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }
        .tv-skin-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('/public/0fd03c8c22139e5f07019038989514d5.png') center/contain no-repeat;
            pointer-events: none;
            z-index: 100;
        }
        .tv-screen-wrapper {
            position: relative;
            width: 100%;
            padding-top: 90.75%; /* 22% taller than 4:3 (10% more compression) for very tall videos */
            background: var(--tv-screen);
            border-radius: 15px;
            overflow: hidden; /* Ensures no content spills outside */
            max-width: 100%; /* Prevent container overflow */
            border: 2px solid var(--rust-metal);
            box-shadow: inset 0 0 20px rgba(255, 107, 53, 0.2);
        }
        .tv-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Double protection against video overflow */
        }
        .video-player {
            width: 100%;
            height: 100%;
            max-width: 100%; /* Prevent video from exceeding container width */
            max-height: 100%; /* Prevent video from exceeding container height */
            object-fit: cover; /* Fill screen without side borders */
            object-position: 50% 30%; /* Focus lower for 9:16 videos, avoid cutting important content */
            background: var(--tv-screen);
            filter: blur(1px) saturate(1.3) hue-rotate(180deg); /* Enhanced cyberpunk TV effect */
        }
        .scan-lines {
            position: absolute;
            top: -5px;
            left: -5px;
            width: calc(100% + 10px);
            height: calc(100% + 10px);
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 255, 0.1),
                rgba(0, 255, 255, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 9; /* Below static but above content */
            animation: scanlineMove 0.05s linear infinite;
        }
        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(6px); }
        }
        .tv-static {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 10; /* Above all content including NOW PLAYING */
            overflow: hidden;
            filter: blur(5px); /* Even more blur for smoother static */
            image-rendering: auto; /* Enable smooth image rendering */
            image-rendering: smooth; /* Fallback for older browsers */
        }
        .tv-static.active {
            opacity: 1;
        }
        @keyframes rapidStaticFlash {
            0% {
                opacity: 1;
                transform: scale(1.02);
                filter: brightness(1.5) contrast(2);
            }
            25% {
                opacity: 1;
                transform: scale(1.01);
                filter: brightness(1.2) contrast(1.5);
            }
            50% {
                opacity: 1;
                transform: scale(1.015);
                filter: brightness(1.4) contrast(1.8);
            }
            75% {
                opacity: 1;
                transform: scale(1.005);
                filter: brightness(1.1) contrast(1.3);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: brightness(1) contrast(1);
            }
        }
        /* Rapid temporal refresh for continuous static effect */
        .tv-static.temporal-refresh {
            opacity: 1;
        }
        #noiseCanvas {
            width: 100%;
            height: 100%;
            image-rendering: auto;
            image-rendering: smooth;
            -webkit-optimize-contrast: auto;
        }
        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'VT323', monospace;
            font-size: 2rem;
            color: var(--primary);
            text-shadow: 0 0 20px var(--primary);
            z-index: 4;
        }
        .now-playing {
            position: absolute;
            top: 20px;
            left: 20px;
            background: none; /* Remove background */
            padding: 5px;
            border-radius: 0;
            font-family: 'VT323', monospace;
            font-size: 2.1rem; /* 30% bigger than 1.6rem */
            color: #ffffff;
            z-index: 1; /* Below static and scanlines */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); /* Add shadow for readability */
            transition: opacity 0.5s ease;
            filter: blur(1px); /* Add blur to match TV aesthetic */
        }
        .logo-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1; /* Below static and scanlines */
            pointer-events: none; /* Don't interfere with mouse events */
        }
        .logo-image {
            max-width: 194px;
            max-height: 194px;
            width: auto;
            height: auto;
            filter: blur(1.5px); /* Apply blur effect */
            opacity: 1.0; /* Fully opaque */
        }
        .qr-code {
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
        }
        .qr-image {
            width: 194px;
            height: 194px;
            background: white;
            padding: 4px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            filter: blur(1.5px); /* Apply blur effect to match logo */
        }
        .url-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: 'VT323', monospace;
            font-size: 3rem; /* 2.5x bigger than 1.2rem */
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 1; /* Below static and scanlines */
            pointer-events: none; /* Don't interfere with mouse events */
            filter: blur(1px); /* Apply blur effect to match TV aesthetic */
        }
        /* Fullscreen styles - maintain 4:3 aspect ratio, hide controls, maximize size */
        .tv-container:fullscreen {
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .tv-container:fullscreen .tv-skin-overlay {
            background-size: cover;
        }
        .tv-container:fullscreen .tv-screen-wrapper {
            /* Calculate largest possible 4:3 rectangle that fits in viewport */
            width: min(100vw, 133.33vh); /* 4:3 ratio: width = height * 4/3 */
            height: min(100vh, 75vw); /* 4:3 ratio: height = width * 3/4 */
            max-width: 100vw;
            max-height: 100vh;
            padding-top: 0;
            background: var(--tv-screen);
            border-radius: 0;
        }
        .tv-container:fullscreen .tv-controls {
            display: none; /* Hide controls completely in fullscreen */
        }
        /* Webkit fullscreen support */
        .tv-container:-webkit-full-screen {
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .tv-container:-webkit-full-screen .tv-skin-overlay {
            background-size: cover;
        }
        .tv-container:-webkit-full-screen .tv-screen-wrapper {
            /* Calculate largest possible 4:3 rectangle that fits in viewport */
            width: min(100vw, 133.33vh); /* 4:3 ratio: width = height * 4/3 */
            height: min(100vh, 75vw); /* 4:3 ratio: height = width * 3/4 */
            max-width: 100vw;
            max-height: 100vh;
            padding-top: 0;
            background: var(--tv-screen);
            border-radius: 0;
        }
        .tv-container:-webkit-full-screen .tv-controls {
            display: none; /* Hide controls completely in fullscreen */
        }
        /* Mozilla fullscreen support */
        .tv-container:-moz-full-screen {
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .tv-container:-moz-full-screen .tv-skin-overlay {
            background-size: cover;
        }
        .tv-container:-moz-full-screen .tv-screen-wrapper {
            /* Calculate largest possible 4:3 rectangle that fits in viewport */
            width: min(100vw, 133.33vh); /* 4:3 ratio: width = height * 4/3 */
            height: min(100vh, 75vw); /* 4:3 ratio: height = width * 3/4 */
            max-width: 100vw;
            max-height: 100vh;
            padding-top: 0;
            background: var(--tv-screen);
            border-radius: 0;
        }
        .tv-container:-moz-full-screen .tv-controls {
            display: none; /* Hide controls completely in fullscreen */
        }
        /* Fullscreen exit hint */
        .tv-container:fullscreen .fullscreen-hint,
        .tv-container:-webkit-full-screen .fullscreen-hint,
        .tv-container:-moz-full-screen .fullscreen-hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 101;
            opacity: 1;
            animation: fadeOut 3s ease-in-out forwards;
            pointer-events: none;
        }
        /* Iframe embed mode - auto fullscreen 4:3 */
        body.iframe-mode {
            padding: 0;
            margin: 0;
            background: #000;
        }
        body.iframe-mode .hero-section {
            display: none; /* Hide everything except TV */
        }
        body.iframe-mode .tv-container {
            width: 100vw;
            height: 100vh;
            max-width: none;
            padding: 0;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        body.iframe-mode .tv-screen-wrapper {
            width: min(100vw, 133.33vh); /* 4:3 ratio: width = height * 4/3 */
            height: min(100vh, 75vw); /* 4:3 ratio: height = width * 3/4 */
            max-width: 100vw;
            max-height: 100vh;
            padding-top: 0;
            background: var(--tv-screen);
            border-radius: 0;
        }
        body.iframe-mode .tv-controls {
            display: none; /* Hide controls in iframe embed */
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        .tv-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        .tv-button {
            background: linear-gradient(135deg, var(--dive-bar-dark), var(--dirty-wall));
            border: 2px solid var(--neon-sign);
            color: var(--beer-foam);
            padding: 15px 30px;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'VT323', 'Press Start 2P', monospace;
            font-weight: 700;
            font-size: 1.1rem;
            transition: all 0.4s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            box-shadow:
                0 8px 25px rgba(255, 107, 53, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .tv-button:hover {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.3), var(--dive-bar-dark));
            border: 2px solid var(--neon-blue);
            color: var(--neon-sign);
            transform: translateY(-3px) scale(1.05);
            box-shadow:
                0 15px 40px rgba(255, 107, 53, 0.5),
                0 0 30px rgba(0, 212, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .tv-button:active {
            transform: translateY(-1px) scale(1.02);
        }
        .tv-button i {
            font-size: 1.2rem;
        }
        .volume-control {
            position: relative;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .volume-knob {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--dark-wood), var(--dive-bar-dark));
            border: 3px solid var(--neon-sign);
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            box-shadow:
                0 4px 15px rgba(255, 107, 53, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .volume-knob:hover {
            transform: scale(1.05);
            box-shadow:
                0 8px 25px rgba(255, 107, 53, 0.4),
                0 0 20px rgba(0, 212, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .volume-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 20px;
            background: var(--neon-sign);
            border-radius: 2px;
            transform-origin: center bottom;
            transition: transform 0.3s ease;
            box-shadow: 0 0 10px var(--neon-sign);
        }
        .volume-level {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            color: var(--beer-foam);
            min-width: 40px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 1;
        }
        @media (max-width: 768px) {
            .navbar {
                flex-wrap: wrap;
                max-width: 90%;
                gap: 10px;
            }

            .navbar a {
                padding: 8px 12px;
                font-size: 14px;
            }

            .hero-title {
                font-size: 2.5rem;
            }

            .hero-subtitle {
                font-size: 1.3rem;
            }

            .hero-section {
                padding: 100px 0 40px;
            }

            .tv-container {
                padding: 20px;
            }

            .tv-button {
                padding: 12px 20px;
                font-size: 0.9rem;
            }

            .volume-knob {
                width: 50px;
                height: 50px;
            }

            .now-playing {
                font-size: 1rem;
                padding: 8px 15px;
            }

            .logo-overlay {
                bottom: 10px;
                right: 10px;
            }

            .logo-image {
                max-width: 80px;
                max-height: 80px;
            }

            .qr-image {
                width: 80px;
                height: 80px;
                padding: 2px;
            }

            .url-display {
                bottom: 10px;
                left: 10px;
                font-size: 2.5rem; /* 2.5x bigger than 1rem */
            }
        }
        @media (max-width: 480px) {
            .logo-overlay {
                bottom: 8px;
                right: 8px;
            }

            .logo-image {
                max-width: 60px;
                max-height: 60px;
            }

            .qr-image {
                width: 60px;
                height: 60px;
                padding: 1px;
            }

            .url-display {
                bottom: 8px;
                left: 8px;
                font-size: 2.25rem; /* 2.5x bigger than 0.9rem */
            }
        }
        /* Hero Section Styles - matching other pages */
        .hero-section {
            text-align: center;
            padding: 140px 0 80px;
            position: relative;
        }
        .hero-title {
            font-size: 3.5rem;
            color: var(--neon-sign);
            margin-bottom: 20px;
            text-shadow:
                0 0 10px var(--neon-sign),
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 107, 53, 0.5);
            line-height: 1.1;
            font-weight: 700;
            font-family: 'Press Start 2P', 'VT323', monospace;
            animation: titleGlitch 4s ease-in-out infinite;
        }
        @keyframes titleGlitch {
            0%, 90%, 100% {
                transform: translate(0);
                filter: hue-rotate(0deg) brightness(1);
                text-shadow: 0 0 10px var(--neon-sign), 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 20px rgba(255, 107, 53, 0.5);
            }
            91% {
                transform: translate(-2px, 2px);
                filter: hue-rotate(90deg) brightness(1.2);
                text-shadow: 2px 2px 0 var(--graffiti-red), -2px -2px 0 var(--neon-blue);
            }
            92% {
                transform: translate(2px, -2px);
                filter: hue-rotate(180deg) brightness(0.8);
                text-shadow: -2px 2px 0 var(--terminal-green), 2px -2px 0 var(--urine-stain);
            }
            93% {
                transform: translate(-1px, 1px);
                filter: hue-rotate(270deg) brightness(1.1);
                text-shadow: 1px -1px 0 var(--neon-blue), -1px 1px 0 var(--spilled-beer);
            }
        }
        .hero-subtitle {
            font-size: 1.4rem;
            color: var(--beer-foam);
            margin-bottom: 40px;
            font-weight: 400;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            animation: subtitleFlicker 3s ease-in-out infinite;
        }
        @keyframes subtitleFlicker {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
            75% { opacity: 0.95; }
        }
        /* Add missing CSS variables from other pages for consistency */
        :root {
            /* Dive bar theme variables for compatibility */
            --dive-bar-bg: #1a1a1a;
            --dive-bar-dark: #0d0d0d;
            --beer-foam: #f5e6d3;
            --dirty-wall: #2d2d2d;
            --neon-sign: #ff6b35;
            --neon-blue: #00d4ff;
            --spilled-beer: #8b6914;
            --graffiti-red: #ff1744;
            --terminal-green: #00ff41;
            --urine-stain: #c4b000;
            --rust-metal: #8b4513;
            --bar-stool: #4a3c28;
        }
    </style>
  <link rel="stylesheet" crossorigin href="/assets/navbar-Bdw0hUDl.css">
  <link rel="stylesheet" crossorigin href="/assets/style-ERVDcyL7.css">
  <link rel="stylesheet" crossorigin href="/assets/lore-D6iLehCu.css">
</head>
<body>
    <div class="terminal-scanlines"></div>
    <div class="terminal-flicker"></div>

    <!-- Beer Drip Animations -->
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>
    <div class="beer-drip"></div>

    <!-- Navigation -->
    <nav class="navbar">
        <a href="index.html">
            <i class="fas fa-beer"></i>
            üç∫ Bar
        </a>
        <a href="lore.html">
            <i class="fas fa-scroll"></i>
            üìú Stories
        </a>
        <a href="images-thread.html">
            <i class="fas fa-images"></i>
            üñºÔ∏è Memes
        </a>
        <a href="videos-thread.html" class="active">
            <i class="fas fa-tv"></i>
            üì∫ TV
        </a>
        <a href="https://420360.xyz/" target="_blank">
            <i class="fas fa-wifi"></i>
            üåê World
        </a>
        <a href="https://thirdweb.com/somnia/0x1Fb25216baC410872CF548cc9A1D1B9B00F67A12" target="_blank">
            <i class="fas fa-coins"></i>
            üí∞ Beer
        </a>
    </nav>

    <div class="container">
        <div class="hero-section">
            <h1 class="hero-title">üçª 247420 Dive Bar TV Room</h1>
            <p class="hero-subtitle">Where Drunk Hackers & Meme Culturists Watch Chaotic Broadcasts</p>
        </div>

    <div class="tv-container">
        <div class="tv-skin-overlay"></div>
        <div class="fullscreen-hint" id="fullscreenHint" style="display: none;">PRESS ESC TO EXIT FULLSCREEN</div>
        <div class="tv-screen-wrapper">
            <div class="tv-screen">
                <video id="currentVideo" class="video-player" autoplay muted></video>
                <video id="nextVideo" class="video-player" style="display: none;" preload="auto"></video>
                <video id="thirdVideo" class="video-player" style="display: none;" preload="auto"></video>
                <div class="scan-lines"></div>
                <div class="tv-static" id="static">
                    <canvas id="noiseCanvas"></canvas>
                </div>
                <div class="vignette"></div>
                <div class="loading-text" id="loadingText">INITIALIZING QUANTUM STREAM...</div>
                <div class="now-playing" id="nowPlaying" style="display: none;">
                    <i class="fas fa-satellite-dish"></i> TRANSMITTING: DIGITAL SIGNAL
                </div>
                <div class="url-display">
                    247420.247420.xyz
                </div>
                <div class="logo-overlay">
                    <div class="qr-code">
                        <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=https://schwpe.247420.xyz" alt="QR Code" class="qr-image">
                    </div>
                    <img src="/logo.gif" alt="Logo" class="logo-image">
                </div>
            </div>
            <!-- Audio noise/static element -->
            <audio id="staticNoise" loop preload="auto"></audio>
        </div>

        <div class="tv-controls">
            <button class="tv-button" id="changeChannel">
                <i class="fas fa-random"></i>
                CHANGE CHANNEL
            </button>
            <button class="tv-button" id="fullscreenToggle">
                <i class="fas fa-expand"></i>
                FULLSCREEN
            </button>
            <div class="volume-control">
                <div class="volume-knob" id="volumeKnob">
                    <div class="volume-indicator" id="volumeIndicator"></div>
                </div>
                <div class="volume-level" id="volumeLevel">0</div>
            </div>
        </div>

        </div>
    </div>

    <script>
        class Schwelevision {
            constructor() {
                this.videos = [];
                this.playedVideos = new Set();
                this.currentVideoElement = document.getElementById('currentVideo');
                this.nextVideoElement = document.getElementById('nextVideo');
                this.thirdVideoElement = document.getElementById('thirdVideo');
                this.staticNoiseElement = document.getElementById('staticNoise');
                this.staticElement = document.getElementById('static');
                this.noiseCanvas = document.getElementById('noiseCanvas');
                this.noiseCtx = this.noiseCanvas.getContext('2d');
                this.currentIndex = -1;

                // Check if loaded in iframe and enable embed mode
                this.checkIframeMode();
                this.nextIndex = -1;
                this.thirdIndex = -1;
                this.volume = 0;
                this.isDragging = false;
                this.noiseAnimationId = null;
                this.isVideoPreloaded = false;
                this.isThirdVideoPreloaded = false;

                // Synchronized programming system
                this.PROGRAM_SEED = 247420;
                this.schedule = [];
                this.currentProgramIndex = 0;
                this.scheduledPlayTimeout = null;

                // Weekly schedule system
                this.weeklySchedule = null;
                this.currentWeek = null;
                this.scheduleStart = null;
                this.isScheduledVideoPlaying = false;

                // Loop scheduling system
                this.loopSchedule = [];
                this.loopDuration = 3600000; // 1 hour default
                this.epochStart = new Date('2025-01-01T00:00:00Z').getTime();

                this.initAudioNoise();
                this.initNoiseCanvas();
            }

            checkIframeMode() {
                // Check if we're in an iframe
                if (window.self !== window.top) {
                    console.log('üì∫ Schwelevision loaded in iframe - enabling embed mode');
                    document.body.classList.add('iframe-mode');

                    // Optionally, we can also communicate with parent window
                    try {
                        window.parent.postMessage({
                            type: 'schwelevision-ready',
                            aspectRatio: '4:3',
                            isFullscreen: true
                        }, '*');
                    } catch (e) {
                        console.log('üì∫ Cross-origin iframe detected');
                    }
                }
            }

            async init() {
                await this.loadVideos();
                await this.loadWeeklySchedule();
                this.setupEventListeners();
                this.setupVolumeControl();
                this.setupAudioInteraction();
                this.startNoiseAnimation();
                this.generateProgramSchedule();
                await this.startHybridBroadcast();
            }

            async loadVideos() {
                try {
                    const response = await fetch('/saved_videos.json');
                    if (!response.ok) throw new Error('Failed to fetch videos');

                    this.videos = await response.json();

                    // Create loop schedule from videos for continuous programming
                    if (Object.keys(this.videos).length > 0) {
                        this.createLoopSchedule();
                    }

                    // If no videos loaded, create a default test video
                    if (Object.keys(this.videos).length === 0) {
                        this.videos = {
                            "test-video.mp4": {
                                "title": "Test Video for 247420",
                                "description": "A test video to verify the video player functionality",
                                "duration": 30,
                                "filename": "test-video.mp4"
                            }
                        };
                        console.log('üì∫ Using default test video');
                    }

                    // Convert videos object to array format for easier indexing
                    this.videos = Object.keys(this.videos).map(filename => ({
                        filename: filename,
                        ...this.videos[filename]
                    }));

                    console.log(`üì∫ Loaded ${this.videos.length} videos for Schwelevision`);
                } catch (error) {
                    console.error('‚ùå Error loading videos:', error);
                    // Create fallback video data
                    this.videos = [{
                        "filename": "test-video.mp4",
                        "title": "Test Video for 247420",
                        "description": "A test video to verify the video player functionality",
                        "duration": 30
                    }];
                    console.log('üì∫ Using fallback test video');
                    document.getElementById('loadingText').textContent = 'TEST SIGNAL';
                }
            }

            createLoopSchedule() {
                const videoArray = Object.keys(this.videos).map(filename => ({
                    filename: filename,
                    ...this.videos[filename]
                }));

                this.loopSchedule = [];
                let offsetMs = 0;

                // Create continuous loop from available videos
                while (offsetMs < this.loopDuration) {
                    for (const video of videoArray) {
                        if (offsetMs >= this.loopDuration) break;

                        const duration = (video.duration || 30) * 1000;
                        this.loopSchedule.push({
                            filename: video.filename,
                            duration: duration,
                            offsetMs: offsetMs,
                            videoIndex: this.videos.findIndex(v => v.filename === video.filename)
                        });

                        offsetMs += duration + 2000; // 2 second gap between videos
                    }
                }

                console.log(`üì∫ Created loop schedule with ${this.loopSchedule.length} slots, duration: ${(this.loopDuration / 60000).toFixed(1)}min`);
            }

            async loadWeeklySchedule() {
                try {
                    const currentWeek = this.getCurrentWeek();
                    await this.loadWeekData(currentWeek);
                    console.log(`üìÖ Loaded weekly schedule for week ${currentWeek}`);
                } catch (error) {
                    console.log('‚ö†Ô∏è Could not load weekly schedule, using default programming:', error.message);
                    this.weeklySchedule = null;
                }
            }

            getCurrentWeek() {
                const now = new Date();
                const gmt = Date.UTC(
                    now.getUTCFullYear(),
                    now.getUTCMonth(),
                    now.getUTCDate(),
                    now.getUTCHours(),
                    now.getUTCMinutes(),
                    now.getUTCSeconds()
                );

                const start = new Date('2025-10-11T00:00:00Z');
                const elapsed = gmt - start.getTime();
                if (elapsed < 0) return 1;

                const week = Math.floor(elapsed / (7 * 24 * 60 * 60 * 1000)) + 1;
                return week;
            }

            async loadWeekData(week) {
                try {
                    const response = await fetch(`/schedule_weeks/week_${week}.json`);
                    if (!response.ok) {
                        throw new Error(`Week ${week} not found`);
                    }

                    const scheduleData = await response.json();
                    this.weeklySchedule = scheduleData;
                    this.scheduleStart = new Date(scheduleData.m.start);
                    this.currentWeek = week;
                } catch (error) {
                    throw new Error(`Failed to load week ${week}: ${error.message}`);
                }
            }

            async getCurrentScheduledVideo() {
                if (!this.weeklySchedule) return null;

                const now = new Date();
                const gmt = Date.UTC(
                    now.getUTCFullYear(),
                    now.getUTCMonth(),
                    now.getUTCDate(),
                    now.getUTCHours(),
                    now.getUTCMinutes(),
                    now.getUTCSeconds()
                );

                if (this.scheduleStart) {
                    const scheduleStartGMT = Date.UTC(
                        this.scheduleStart.getUTCFullYear(),
                        this.scheduleStart.getUTCMonth(),
                        this.scheduleStart.getUTCDate(),
                        this.scheduleStart.getUTCHours(),
                        this.scheduleStart.getUTCMinutes(),
                        this.scheduleStart.getUTCSeconds()
                    );

                    const elapsedInWeek = gmt - scheduleStartGMT;
                    if (elapsedInWeek < 0) return null;

                    const day = Math.floor(elapsedInWeek / (24 * 60 * 60 * 1000));
                    const hour = Math.floor((elapsedInWeek % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));

                    const scheduleStartDay = 6; // Saturday
                    const currentDay = (scheduleStartDay + day) % 7;
                    const dayIndex = currentDay === 0 ? 6 : currentDay - 1;
                    const dayName = this.weeklySchedule.m.days[dayIndex];

                    const slots = this.weeklySchedule.s.filter(s =>
                        s.d === dayName && this.parseTime(s.t) === hour
                    );

                    if (slots.length === 0) return null;

                    const slot = slots[0];
                    const video = this.weeklySchedule.v[slot.v];

                    if (video) {
                        return {
                            ...video,
                            duration: (video.du || slot.du || 30) * 1000,
                            filename: video.filename || `scheduled_${slot.v}.mp4`
                        };
                    }
                }

                return null;
            }

            parseTime(timeStr) {
                const match = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!match) return 0;

                let hour = parseInt(match[1]);
                const period = match[3];
                if (period === 'PM' && hour !== 12) hour += 12;
                if (period === 'AM' && hour === 12) hour = 0;
                return hour;
            }

            seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }

            generateProgramSchedule() {
                const now = Date.now();
                const elapsedSinceEpoch = now - this.epochStart;
                const currentLoopPosition = elapsedSinceEpoch % this.loopDuration;

                const currentSlot = this.loopSchedule.find(slot =>
                    slot.offsetMs <= currentLoopPosition && slot.offsetMs + slot.duration > currentLoopPosition
                );

                if (currentSlot) {
                    this.currentProgramIndex = this.loopSchedule.indexOf(currentSlot);
                    console.log(`üì∫ Synced to loop position ${this.currentProgramIndex}: ${currentSlot.filename}`);
                } else {
                    this.currentProgramIndex = this.loopSchedule.findIndex(slot => slot.offsetMs > currentLoopPosition);
                    if (this.currentProgramIndex === -1) this.currentProgramIndex = 0;
                    console.log(`üì∫ Waiting for next program at index ${this.currentProgramIndex}`);
                }
            }

                  async startHybridBroadcast() {
                // Check for scheduled video first
                const scheduledVideo = await this.getCurrentScheduledVideo();

                if (scheduledVideo && scheduledVideo.filename) {
                    console.log(`üìÖ Scheduled video detected: ${scheduledVideo.show || scheduledVideo.filename}`);
                    await this.playWeeklyScheduledVideo(scheduledVideo);
                    this.isScheduledVideoPlaying = true;
                } else {
                    // No scheduled video, play regular 247420 content
                    console.log('üì∫ No scheduled video, playing regular 247420 content');
                    this.isScheduledVideoPlaying = false;
                    await this.startSynchronizedBroadcast();
                }
            }

            async playWeeklyScheduledVideo(video) {
                // Show static briefly before scheduled content
                this.staticElement.classList.add('active', 'temporal-refresh');
                this.playStaticNoise();

                const videoPath = video.filename.startsWith('http')
                    ? video.filename
                    : `/saved_videos/${video.filename}`;

                this.currentVideoElement.src = videoPath;
                this.currentVideoElement.volume = this.volume / 100;
                this.currentVideoElement.muted = this.volume === 0;
                this.currentVideoElement.preload = 'auto';
                this.currentVideoElement.load();

                try {
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            console.log('‚ö†Ô∏è Scheduled video timeout, playing anyway');
                            resolve();
                        }, 10000);

                        this.currentVideoElement.addEventListener('canplay', () => {
                            clearTimeout(timeout);
                            resolve();
                        }, { once: true });

                        this.currentVideoElement.addEventListener('error', (e) => {
                            clearTimeout(timeout);
                            reject(e);
                        }, { once: true });
                    });

                    // Clear static and play scheduled video
                    this.staticElement.classList.remove('active', 'temporal-refresh');
                    this.stopStaticNoise();

                    document.getElementById('loadingText').style.display = 'none';
                    document.getElementById('nowPlaying').style.display = 'block';
                    document.getElementById('nowPlaying').innerHTML = `<i class="fas fa-satellite-dish"></i> SCHEDULED: ${video.show || video.filename}`;

                    await this.currentVideoElement.play();

                    // Set timeout for video end
                    setTimeout(() => {
                        this.onScheduledVideoEnd();
                    }, video.duration + 2000);

                    console.log(`üìÖ Playing scheduled video: ${video.filename}`);
                } catch (error) {
                    console.error('‚ùå Error playing scheduled video:', error);
                    this.onScheduledVideoEnd();
                }
            }

            async startSynchronizedBroadcast() {
                const now = Date.now();
                const elapsedSinceEpoch = now - this.epochStart;
                const currentLoopPosition = elapsedSinceEpoch % this.loopDuration;
                const currentSlot = this.loopSchedule[this.currentProgramIndex];
                const slotStartTime = this.epochStart + Math.floor(elapsedSinceEpoch / this.loopDuration) * this.loopDuration + currentSlot.offsetMs;

                if (!currentSlot) {
                    console.error('‚ùå No program slot found');
                    return;
                }

                const timeUntilStart = slotStartTime - now;
                const timeIntoVideo = now - slotStartTime;

                // Only show static and wait if we're MORE than 500ms early
                if (timeUntilStart > 500) {
                    console.log(`üì∫ Static until program starts in ${(timeUntilStart / 1000).toFixed(1)}s`);
                    this.staticElement.classList.add('active', 'temporal-refresh');
                    this.playStaticNoise();

                    await this.preloadScheduledVideo(this.currentProgramIndex);

                    this.scheduledPlayTimeout = setTimeout(() => {
                        this.playScheduledVideo();
                    }, timeUntilStart);
                } else if (timeIntoVideo < 0 || timeIntoVideo < currentSlot.duration) {
                    // Play immediately if we're within 2s of start time OR already in progress
                    const seekTime = Math.max(0, timeIntoVideo / 1000);
                    console.log(`üì∫ Playing video ${seekTime > 0 ? 'at ' + seekTime.toFixed(1) + 's' : 'from start'}`);
                    await this.preloadScheduledVideo(this.currentProgramIndex);
                    await this.playScheduledVideo(seekTime);
                } else {
                    this.currentProgramIndex++;
                    if (this.currentProgramIndex >= this.loopSchedule.length) {
                        this.currentProgramIndex = 0;
                    }
                    await this.startSynchronizedBroadcast();
                }
            }

            async preloadScheduledVideo(programIndex) {
                if (programIndex >= this.loopSchedule.length) return;

                const slot = this.loopSchedule[programIndex];
                const videoPath = `/saved_videos/${slot.filename}`;

                this.currentVideoElement.src = videoPath;
                this.currentVideoElement.volume = this.volume / 100;
                this.currentVideoElement.muted = this.volume === 0;
                this.currentVideoElement.preload = 'auto';
                this.currentVideoElement.load();

                console.log(`üìº Preloading scheduled video: ${slot.filename}`);

                try {
                    await new Promise((resolve, reject) => {
                        const checkReadyToPlay = () => {
                            // Accept readyState >= 3 (HAVE_FUTURE_DATA) for streaming videos
                            if (this.currentVideoElement.readyState >= 3) {
                                console.log(`‚úÖ Scheduled video ready to play (readyState: ${this.currentVideoElement.readyState})`);
                                resolve();
                            }
                        };

                        // Check immediately in case video is already ready
                        if (this.currentVideoElement.readyState >= 3) {
                            console.log(`‚úÖ Video already ready (readyState: ${this.currentVideoElement.readyState})`);
                            resolve();
                            return;
                        }

                        this.currentVideoElement.addEventListener('canplay', checkReadyToPlay, { once: true });
                        this.currentVideoElement.addEventListener('canplaythrough', checkReadyToPlay, { once: true });
                        this.currentVideoElement.addEventListener('error', (e) => {
                            const mediaError = this.currentVideoElement.error;
                            reject(new Error(`Video error code ${mediaError?.code}: ${mediaError?.message || 'Unknown error'} - src: ${this.currentVideoElement.src}`));
                        }, { once: true });

                        // Reduce timeout to 5 seconds for faster channel changes
                        setTimeout(() => {
                            console.log('‚ö†Ô∏è Preload timeout, will play anyway');
                            resolve();
                        }, 5000);
                    });

                    this.isVideoPreloaded = true;
                } catch (error) {
                    console.error('‚ùå Failed to preload scheduled video:', error);
                    this.isVideoPreloaded = false;
                }
            }

            async playScheduledVideo(seekTime = 0) {
                const currentSlot = this.loopSchedule[this.currentProgramIndex];
                const now = Date.now();
                const elapsedSinceEpoch = now - this.epochStart;
                const slotStartTime = this.epochStart + Math.floor(elapsedSinceEpoch / this.loopDuration) * this.loopDuration + currentSlot.offsetMs;
                const actualSeekTime = (now - slotStartTime) / 1000;

                if (!this.isVideoPreloaded) {
                    console.log('‚ö†Ô∏è Video not fully loaded, staying on static');

                    const checkInterval = setInterval(async () => {
                        if (this.isVideoPreloaded) {
                            clearInterval(checkInterval);
                            const newNow = Date.now();
                            const newElapsed = newNow - this.epochStart;
                            const newSlotStart = this.epochStart + Math.floor(newElapsed / this.loopDuration) * this.loopDuration + currentSlot.offsetMs;
                            const newSeekTime = (newNow - newSlotStart) / 1000;

                            if (newSeekTime < currentSlot.duration / 1000) {
                                console.log(`‚úÖ Video loaded, joining at ${newSeekTime.toFixed(1)}s`);
                                await this.playScheduledVideo(newSeekTime);
                            } else {
                                console.log('‚è≠Ô∏è Video took too long to load, skipping to next');
                                this.currentProgramIndex++;
                                this.onScheduledVideoEnd();
                            }
                        }
                    }, 100);

                    setTimeout(() => {
                        if (!this.isVideoPreloaded) {
                            clearInterval(checkInterval);
                            console.log('‚è≠Ô∏è Load timeout, skipping to next');
                            this.currentProgramIndex++;
                            this.onScheduledVideoEnd();
                        }
                    }, 60000);

                    return;
                }

                // Check if video is ready to play (readyState >= 3 for streaming)
                if (this.currentVideoElement.readyState < 3) {
                    console.log(`‚ö†Ô∏è Video not ready (readyState: ${this.currentVideoElement.readyState}), retrying...`);
                    this.isVideoPreloaded = false;
                    setTimeout(() => this.playScheduledVideo(actualSeekTime), 100);
                    return;
                }

                this.staticElement.classList.remove('active', 'temporal-refresh');
                this.stopStaticNoise();

                this.noiseCtx.clearRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);
                this.noiseCtx.fillStyle = '#000000';
                this.noiseCtx.fillRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);

                document.getElementById('currentVideo').style.display = 'block';
                document.getElementById('nextVideo').style.display = 'none';
                document.getElementById('thirdVideo').style.display = 'none';
                document.querySelector('.scan-lines').style.display = 'block';
                document.querySelector('.vignette').style.display = 'block';
                document.querySelector('.logo-overlay').style.display = 'block';

                if (actualSeekTime > 0 && actualSeekTime < currentSlot.duration / 1000) {
                    this.currentVideoElement.currentTime = actualSeekTime;
                    console.log(`‚è© Seeking to ${actualSeekTime.toFixed(1)}s to sync with schedule`);
                }

                await this.currentVideoElement.play();

                document.getElementById('loadingText').style.display = 'none';
                document.getElementById('nowPlaying').style.display = 'block';

                const remainingTime = currentSlot.duration - (actualSeekTime * 1000);

                const endVideo = () => {
                    this.onScheduledVideoEnd();
                };

                this.currentVideoElement.addEventListener('ended', endVideo, { once: true });

                // Use SCHEDULED duration to maintain perfect sync across all clients
                const scheduledEndTimeout = remainingTime;
                setTimeout(endVideo, scheduledEndTimeout);

                // Preload next video BEFORE incrementing index
                const nextIndex = (this.currentProgramIndex + 1) % this.loopSchedule.length;
                await this.preloadScheduledVideo(nextIndex);

                console.log(`üì∫ Playing fully buffered video with ${(remainingTime / 1000).toFixed(1)}s remaining`);
            }

            onScheduledVideoEnd() {
                console.log('üì∫ Loop video ended, checking for scheduled content');

                // ALWAYS stop and mute all videos first
                this.currentVideoElement.pause();
                this.nextVideoElement.pause();
                this.thirdVideoElement.pause();
                this.currentVideoElement.volume = 0;
                this.nextVideoElement.volume = 0;
                this.thirdVideoElement.volume = 0;

                // Hide all video elements completely
                document.getElementById('currentVideo').style.display = 'none';
                document.getElementById('nextVideo').style.display = 'none';
                document.getElementById('thirdVideo').style.display = 'none';

                // Increment index immediately
                this.currentProgramIndex++;
                if (this.currentProgramIndex >= this.loopSchedule.length) {
                    this.currentProgramIndex = 0;
                }

                // 20% chance to show brief static transition for retro TV effect
                if (Math.random() < 0.2) {
                    console.log('üì∫ Random static transition');

                    this.staticElement.classList.add('active', 'temporal-refresh');
                    this.playStaticNoise();

                    setTimeout(() => {
                        this.startHybridBroadcast();
                    }, 2000);
                } else {
                    // Go directly to next content
                    this.startHybridBroadcast();
                }
            }

            getRandomIndex() {
                if (this.videos.length === 0) return -1;

                // Get list of unplayed videos
                const unplayedVideos = this.videos.map((video, index) => ({ video, index }))
                    .filter(item => !this.playedVideos.has(item.video.filename));

                // If all videos have been played, reset the history
                if (unplayedVideos.length === 0) {
                    console.log('üîÑ All videos played, resetting history');
                    this.playedVideos.clear();
                    return Math.floor(Math.random() * this.videos.length);
                }

                // Bias heavily towards unplayed videos (90% chance)
                if (Math.random() < 0.9 && unplayedVideos.length > 0) {
                    // Select from unplayed videos
                    const randomUnplayed = unplayedVideos[Math.floor(Math.random() * unplayedVideos.length)];
                    console.log(`üéØ Selected unplayed video: ${randomUnplayed.video.filename} (${this.playedVideos.size}/${this.videos.length} played)`);
                    return randomUnplayed.index;
                }

                // Fallback to completely random selection
                const randomIndex = Math.floor(Math.random() * this.videos.length);
                console.log(`üé≤ Random fallback selected: ${this.videos[randomIndex].filename} (${this.playedVideos.size}/${this.videos.length} played)`);
                return randomIndex;
            }

            async playRandomVideo() {
                if (this.videos.length === 0) return;

                // Start noise animation
                this.startNoiseAnimation();
                this.staticElement.classList.add('active', 'temporal-refresh');
                this.playStaticNoise();

                // If we have a preloaded video, play it immediately
                if (this.isVideoPreloaded && this.nextIndex !== -1) {
                    this.currentIndex = this.nextIndex;

                    // Track this video as played
                    if (this.currentIndex >= 0 && this.currentIndex < this.videos.length) {
                        this.playedVideos.add(this.videos[this.currentIndex].filename);
                    }

                    this.nextIndex = this.thirdIndex;
                    this.thirdIndex = -1;
                    this.isVideoPreloaded = this.isThirdVideoPreloaded;
                    this.isThirdVideoPreloaded = false;

                    this.rotateVideoElements();

                    // HIDE STATIC immediately since we have a preloaded video ready
                    this.staticElement.classList.remove('active', 'temporal-refresh');
                    this.stopStaticNoise();
                    // Keep animation running for smooth transitions

                    // Clear the canvas completely to ensure static is hidden
                    this.noiseCtx.clearRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);

                    // Restore ONLY necessary video elements
                    document.getElementById('currentVideo').style.display = 'block';
                    document.getElementById('nextVideo').style.display = 'none';
                    document.getElementById('thirdVideo').style.display = 'none';
                    document.querySelector('.scan-lines').style.display = 'block';
                    document.querySelector('.vignette').style.display = 'block';
                    document.querySelector('.logo-overlay').style.display = 'block';

                    // Start playing the video immediately after static is cleared
                    this.currentVideoElement.play();

                    // Preload next videos in background without showing static
                    this.preloadNextVideoSequential();

                    console.log('üì∫ Video playing from preloaded source - static completely cleared');
                    return;
                }

                // If no preloaded video, load one and show static until fully loaded
                this.currentIndex = this.getRandomIndex();

                // Track this video as played
                if (this.currentIndex >= 0 && this.currentIndex < this.videos.length) {
                    this.playedVideos.add(this.videos[this.currentIndex].filename);
                }

                const video = this.videos[this.currentIndex];
                const videoPath = `/saved_videos/${video.filename}`;

                this.currentVideoElement.src = videoPath;
                this.currentVideoElement.volume = this.volume / 100;
                this.currentVideoElement.muted = this.volume === 0;

                try {
                    // Wait for entire video to be fully buffered before playing
                    await new Promise((resolve, reject) => {
                        const checkFullyBuffered = () => {
                            if (this.currentVideoElement.readyState === 4) {
                                // HAVE_ENOUGH_DATA: entire video is buffered
                                const buffered = this.currentVideoElement.buffered;
                                if (buffered.length > 0) {
                                    const bufferedEnd = buffered.end(buffered.length - 1);
                                    const duration = this.currentVideoElement.duration;

                                    if (bufferedEnd >= duration - 0.5 || this.currentVideoElement.readyState === 4) {
                                        console.log(`üìº Video fully buffered: ${bufferedEnd.toFixed(1)}s / ${duration.toFixed(1)}s`);
                                        resolve();
                                    }
                                }
                            }
                        };

                        this.currentVideoElement.addEventListener('canplaythrough', checkFullyBuffered, { once: true });
                        this.currentVideoElement.addEventListener('progress', checkFullyBuffered);
                        this.currentVideoElement.addEventListener('error', (e) => {
                            const mediaError = this.currentVideoElement.error;
                            reject(new Error(`Video buffer error code ${mediaError?.code}: ${mediaError?.message || 'Unknown error'} - src: ${this.currentVideoElement.src}`));
                        }, { once: true });

                        // Fallback timeout
                        setTimeout(() => {
                            console.log('‚ö†Ô∏è Buffer timeout, playing anyway');
                            resolve();
                        }, 15000);
                    });

                    // Hide static now that video is fully buffered
                    this.staticElement.classList.remove('active', 'temporal-refresh');
                    this.stopStaticNoise();

                    // Clear the canvas
                    this.noiseCtx.clearRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);
                    this.noiseCtx.fillStyle = '#000000';
                    this.noiseCtx.fillRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);

                    // Restore video elements
                    document.getElementById('currentVideo').style.display = 'block';
                    document.getElementById('nextVideo').style.display = 'none';
                    document.getElementById('thirdVideo').style.display = 'none';
                    document.querySelector('.scan-lines').style.display = 'block';
                    document.querySelector('.vignette').style.display = 'block';
                    document.querySelector('.logo-overlay').style.display = 'block';

                    // Now play the fully buffered video
                    await this.currentVideoElement.play();

                    document.getElementById('loadingText').style.display = 'none';
                    document.getElementById('nowPlaying').style.display = 'block';

                    // Start preloading next videos in background without showing static
                    this.preloadNextVideoSequential();
                } catch (error) {
                    console.error('‚ùå Error playing video:', error);
                    document.getElementById('loadingText').textContent = 'PLAYBACK ERROR';
                    this.stopNoiseAnimation();
                }
            }

            async preloadNextVideo() {
                this.nextIndex = this.getRandomIndex();
                if (this.nextIndex === -1) return;

                const nextVideo = this.videos[this.nextIndex];
                const nextVideoPath = `/saved_videos/${nextVideo.filename}`;

                // Set up enhanced preloading for smooth playback
                this.nextVideoElement.src = nextVideoPath;
                this.nextVideoElement.volume = this.volume / 100;
                this.nextVideoElement.muted = this.volume === 0;
                this.nextVideoElement.preload = 'auto';
                this.nextVideoElement.load();

                // Wait for enough data to play smoothly
                try {
                    await new Promise((resolve, reject) => {
                        this.nextVideoElement.addEventListener('loadeddata', () => {
                            this.isVideoPreloaded = true;
                            console.log(`üìº Preloaded next video (enough data): ${nextVideo.filename}`);
                            resolve();
                        }, { once: true });
                        this.nextVideoElement.addEventListener('error', reject, { once: true });

                        // Fallback timeout
                        setTimeout(() => {
                            this.isVideoPreloaded = true;
                            console.log(`‚ö†Ô∏è Preload for ${nextVideo.filename} completed with timeout`);
                            resolve();
                        }, 5000);
                    });
                } catch (error) {
                    console.log(`‚ùå Preload failed for ${nextVideo.filename}:`, error);
                    this.isVideoPreloaded = false;
                }
            }

            async preloadThirdVideo() {
                this.thirdIndex = this.getRandomIndex();
                if (this.thirdIndex === -1) return;

                const thirdVideo = this.videos[this.thirdIndex];
                const thirdVideoPath = `/saved_videos/${thirdVideo.filename}`;

                // Set up enhanced preloading for smooth playback
                this.thirdVideoElement.src = thirdVideoPath;
                this.thirdVideoElement.volume = this.volume / 100;
                this.thirdVideoElement.muted = this.volume === 0;
                this.thirdVideoElement.preload = 'auto';
                this.thirdVideoElement.load();

                // Wait for enough data to play smoothly
                try {
                    await new Promise((resolve, reject) => {
                        this.thirdVideoElement.addEventListener('loadeddata', () => {
                            this.isThirdVideoPreloaded = true;
                            console.log(`üìº Preloaded third video (enough data): ${thirdVideo.filename}`);
                            resolve();
                        }, { once: true });
                        this.thirdVideoElement.addEventListener('error', reject, { once: true });

                        // Fallback timeout
                        setTimeout(() => {
                            this.isThirdVideoPreloaded = true;
                            console.log(`‚ö†Ô∏è Third preload for ${thirdVideo.filename} completed with timeout`);
                            resolve();
                        }, 5000);
                    });
                } catch (error) {
                    console.log(`‚ùå Third preload failed for ${thirdVideo.filename}:`, error);
                    this.isThirdVideoPreloaded = false;
                }
            }

            async preloadNextVideoSequential() {
                // Preload next video first, then third video sequentially
                await this.preloadNextVideo();

                // Only preload third if next was successful
                if (this.isVideoPreloaded) {
                    await this.preloadThirdVideo();
                }
            }

            rotateVideoElements() {
                // Move next video to current, third to next, and clear third
                this.currentVideoElement.src = this.nextVideoElement.src;
                this.currentVideoElement.volume = this.nextVideoElement.volume;
                this.currentVideoElement.muted = this.nextVideoElement.muted;

                this.nextVideoElement.src = this.thirdVideoElement.src;
                this.nextVideoElement.volume = this.thirdVideoElement.volume;
                this.nextVideoElement.muted = this.thirdVideoElement.muted;

                // Clear third video element
                this.thirdVideoElement.src = '';
                this.thirdVideoElement.volume = 0;
                this.thirdVideoElement.muted = true;

                this.currentVideoElement.style.display = 'block';
                this.nextVideoElement.style.display = 'none';
                this.thirdVideoElement.style.display = 'none';
            }

            swapVideoElements() {
                const tempSrc = this.currentVideoElement.src;
                this.currentVideoElement.src = this.nextVideoElement.src;
                this.nextVideoElement.src = tempSrc;

                this.currentVideoElement.style.display = 'block';
                this.nextVideoElement.style.display = 'none';
            }

            setupVolumeControl() {
                const knob = document.getElementById('volumeKnob');
                const indicator = document.getElementById('volumeIndicator');
                const level = document.getElementById('volumeLevel');

                const updateVolume = (angle) => {
                    this.volume = Math.round(Math.max(0, Math.min(100, angle)));
                    indicator.style.transform = `translate(-50%, -50%) rotate(${this.volume * 2.7 - 135}deg)`;
                    level.textContent = this.volume;

                    this.currentVideoElement.volume = this.volume / 100;
                    this.currentVideoElement.muted = this.volume === 0;

                    // Update static noise volume to match TV volume and mute when needed
                    if (this.gainNode) {
                        if (this.volume === 0) {
                            this.gainNode.gain.value = 0; // Completely mute static when volume is 0
                        } else {
                            const staticVolume = Math.min(0.3, this.volume / 200);
                            this.gainNode.gain.value = staticVolume;
                        }
                    }

                    // Update atmospheric audio volume to match TV volume
                    this.updateAtmosphericVolume();

                    // Play loud crackle when volume changes
                    this.playVolumeCrackle();
                };

                const handleMouseDown = (e) => {
                    this.isDragging = true;
                    e.preventDefault();
                };

                const handleMouseMove = (e) => {
                    if (!this.isDragging) return;

                    const rect = knob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    const degrees = (angle * 180 / Math.PI + 90 + 360) % 360;
                    updateVolume(degrees);
                };

                const handleMouseUp = () => {
                    this.isDragging = false;
                };

                knob.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                knob.addEventListener('touchstart', (e) => {
                    this.isDragging = true;
                    e.preventDefault();
                });

                knob.addEventListener('touchmove', (e) => {
                    if (!this.isDragging) return;
                    const touch = e.touches[0];
                    const rect = knob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const angle = Math.atan2(touch.clientY - centerY, touch.clientX - centerX);
                    const degrees = (angle * 180 / Math.PI + 90 + 360) % 360;
                    updateVolume(degrees);
                });

                knob.addEventListener('touchend', () => {
                    this.isDragging = false;
                });

                updateVolume(0);
            }

            setupAudioInteraction() {
                // Set up user interaction to enable audio
                const enableAudio = () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    // Create static noise on first interaction
                    if (!this.whiteNoiseBuffer) {
                        this.createStaticNoise();
                        // Initialize atmospheric audio volume after creation
                        this.updateAtmosphericVolume();
                    }
                    // Ensure crackle noise is ready
                    if (!this.crackleNoiseBuffer) {
                        this.createCrackleNoise();
                    }
                };

                // Add click listener to document for audio enable
                document.addEventListener('click', enableAudio, { once: true });

                // Also enable on any key press
                document.addEventListener('keydown', enableAudio, { once: true });
            }

            showStaticBetweenVideos() {
                console.log('üì∫ Showing static between videos...');

                // Hide ALL non-static elements for maximum performance
                document.getElementById('currentVideo').style.display = 'none';
                document.getElementById('nextVideo').style.display = 'none';
                document.getElementById('thirdVideo').style.display = 'none';
                document.getElementById('loadingText').style.display = 'none';
                document.getElementById('nowPlaying').style.display = 'none';
                document.querySelector('.scan-lines').style.display = 'none';
                document.querySelector('.vignette').style.display = 'none';
                document.querySelector('.logo-overlay').style.display = 'none';

                // Stop all videos to prevent them from processing
                this.currentVideoElement.pause();
                this.nextVideoElement.pause();
                this.thirdVideoElement.pause();

                // Show static with maximum performance (don't restart animation if already running)
                if (!this.noiseAnimationId) {
                    this.startNoiseAnimation();
                }
                this.staticElement.classList.add('active', 'temporal-refresh');
                this.playStaticNoise();

                // Wait at least 2 seconds for static effect, then play next video
                setTimeout(() => {
                    this.playRandomVideo();
                }, 2000);
            }

            // Canvas noise functionality
            initNoiseCanvas() {
                // Set canvas to lower resolution for better performance
                const rect = this.noiseCanvas.getBoundingClientRect();
                this.noiseCanvas.width = Math.floor(rect.width / 7.5); // 2x higher resolution
                this.noiseCanvas.height = Math.floor(rect.height / 7.5);

                // Enable high-quality image smoothing for better upscaling
                this.noiseCtx.imageSmoothingEnabled = true;
                this.noiseCtx.imageSmoothingQuality = 'high'; // Best quality upscaling

                // CSS blur applied to .tv-static element instead

                // Pre-fill canvas with black before first noise generation
                this.noiseCtx.fillStyle = '#000000';
                this.noiseCtx.fillRect(0, 0, this.noiseCanvas.width, this.noiseCanvas.height);
            }

            generateRandomNoise() {
                const width = this.noiseCanvas.width;
                const height = this.noiseCanvas.height;

                // Create ImageData for direct pixel manipulation (more efficient)
                const imageData = this.noiseCtx.createImageData(width, height);
                const data = imageData.data;

                // Generate noise directly in pixel array for better performance
                for (let i = 0; i < data.length; i += 4) {
                    if (Math.random() > 0.3) { // 70% chance for static
                        const value = Math.random() * 255;
                        data[i] = value;     // Red
                        data[i + 1] = value * 0.9; // Green
                        data[i + 2] = value * 0.8; // Blue
                        data[i + 3] = 255;   // Alpha (fully opaque)
                    } else {
                        data[i] = 0;     // Red
                        data[i + 1] = 0; // Green
                        data[i + 2] = 0; // Blue
                        data[i + 3] = 255; // Alpha (fully opaque)
                    }
                }

                // Put the ImageData back to canvas in one operation
                this.noiseCtx.putImageData(imageData, 0, 0);
            }

            startNoiseAnimation() {
                // Target realistic 30fps for smooth static with good performance
                const targetFPS = 25; // Slightly lower FPS for higher quality static
                const frameInterval = 1000 / targetFPS; // ~33ms per frame
                let then = performance.now();

                const animate = (currentTime) => {
                    const elapsed = currentTime - then;

                    // Only render if enough time has passed for target framerate
                    if (elapsed > frameInterval) {
                        then = currentTime - (elapsed % frameInterval);
                        this.generateRandomNoise();
                    }

                    this.noiseAnimationId = requestAnimationFrame(animate);
                };
                this.noiseAnimationId = requestAnimationFrame(animate);
            }

            stopNoiseAnimation() {
                if (this.noiseAnimationId) {
                    cancelAnimationFrame(this.noiseAnimationId);
                    this.noiseAnimationId = null;
                }
            }

            // Audio noise functionality
            initAudioNoise() {
                // Create procedural static noise using Web Audio API
                this.audioContext = null;
                this.staticNoiseSource = null;
                this.gainNode = null;
            }

            createStaticNoise() {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    // Create white noise using buffer approach
                    const bufferSize = this.audioContext.sampleRate * 2; // 2 seconds of noise
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1; // White noise between -1 and 1
                    }

                    // Create buffer source for continuous noise
                    this.whiteNoiseBuffer = buffer;

                    // Create gain node for volume control
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 0; // Start silent

                    // Create filter for TV static sound
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 1000;
                    filter.Q.value = 1;

                    // Create atmospheric audio effects
                    this.createAtmosphericAudio();

                    // Connect the audio nodes
                    filter.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);

                    this.filterNode = filter;
                    console.log('‚úÖ Static noise audio created with atmospheric effects');
                } catch (error) {
                    console.log('‚ùå Error creating static noise:', error.message);
                }
            }

            createAtmosphericAudio() {
                // Create high-pitched whine (8-12kHz range) with enhanced modulation
                this.whineOscillator = this.audioContext.createOscillator();
                this.whineGain = this.audioContext.createGain();
                this.whineLFO = this.audioContext.createOscillator();
                this.whineLFODepth = this.audioContext.createGain();

                this.whineOscillator.type = 'sine';
                this.whineOscillator.frequency.value = 10000; // 10kHz whine
                this.whineGain.gain.value = 0; // Start silent

                // Add LFO for subtle frequency modulation to create more dynamic whine
                this.whineLFO.type = 'triangle';
                this.whineLFO.frequency.value = 0.2; // Very slow modulation
                this.whineLFODepth.gain.value = 200; // ¬±200Hz variation
                this.whineLFO.connect(this.whineLFODepth);
                this.whineLFODepth.connect(this.whineOscillator.frequency);
                this.whineLFO.start();

                // Create fat hum (60Hz with harmonics) and additional oscillators
                this.humOscillator = this.audioContext.createOscillator();
                this.humGain = this.audioContext.createGain();
                this.humFilter = this.audioContext.createBiquadFilter();
                this.humOscillator2 = this.audioContext.createOscillator(); // Second hum for richness
                this.humGain2 = this.audioContext.createGain();

                this.humOscillator.type = 'sawtooth'; // Rich harmonics for fat sound
                this.humOscillator.frequency.value = 60; // 60Hz hum
                this.humFilter.type = 'lowpass';
                this.humFilter.frequency.value = 200; // Low-pass to create mellow hum
                this.humFilter.Q.value = 0.5;
                this.humGain.gain.value = 0; // Start silent

                this.humOscillator2.type = 'square'; // Different waveform for complexity
                this.humOscillator2.frequency.value = 120; // First harmonic of 60Hz
                this.humGain2.gain.value = 0; // Start silent

                // Create enhanced volume crackle effect with multiple noise sources
                this.crackleGain = this.audioContext.createGain();
                this.crackleFilter = this.audioContext.createBiquadFilter();
                this.crackleFilter2 = this.audioContext.createBiquadFilter();
                this.crackleFilter3 = this.audioContext.createBiquadFilter();
                this.crackleNoiseBuffer = null;
                this.crackleSource = null;
                this.staticCrackleBuffer = null;
                this.staticCrackleSource = null;

                // Enhanced SHARP filters for piercing crackle sound
                this.crackleFilter.type = 'bandpass';
                this.crackleFilter.frequency.value = 7000;
                this.crackleFilter.Q.value = 3.0;

                this.crackleFilter2.type = 'highpass';
                this.crackleFilter2.frequency.value = 8000;
                this.crackleFilter2.Q.value = 5.0;

                this.crackleFilter3.type = 'highpass';
                this.crackleFilter3.frequency.value = 10000;
                this.crackleFilter3.Q.value = 8.0;

                this.crackleGain.gain.value = 0; // Start silent

                this.createCrackleNoise();
                this.createStaticCrackle();

                // Connect hum through filter
                this.humOscillator.connect(this.humFilter);
                this.humFilter.connect(this.humGain);

                // Connect second hum directly with lower volume
                this.humOscillator2.connect(this.humGain2);

                // Connect whine directly
                this.whineOscillator.connect(this.whineGain);

                // Connect crackle through THREE filters for ULTRA SHARP sound
                this.crackleFilter.connect(this.crackleGain);
                this.crackleFilter2.connect(this.crackleGain);
                this.crackleFilter3.connect(this.crackleGain);

                // Start oscillators (they'll be silent until gain is adjusted)
                this.whineOscillator.start();
                this.humOscillator.start();
                this.humOscillator2.start();

                // Connect atmospheric audio to destination
                this.whineGain.connect(this.audioContext.destination);
                this.humGain.connect(this.audioContext.destination);
                this.humGain2.connect(this.audioContext.destination);
                this.crackleGain.connect(this.audioContext.destination);

                console.log('‚úÖ Enhanced atmospheric audio created (whine, dual hum, and crackle)');
            }

            createCrackleNoise() {
                // Create SHARP, QUICK, LOUD, RANDOM crackle effect
                const bufferSize = this.audioContext.sampleRate * 0.08; // 0.08 seconds - much quicker
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    // EXTREMELY random static pattern
                    const randomFactor = Math.random();
                    if (randomFactor > 0.15) { // 85% chance for static (more random)
                        // Ultra-sharp, completely random crackles
                        const staticType = Math.random();
                        if (staticType > 0.85) {
                            // PIERCING spike crackle - SHARP and LOUD
                            output[i] = (Math.random() * 2 - 1) * (Math.random() > 0.7 ? 5.0 : 4.0);
                        } else if (staticType > 0.6) {
                            // Sharp crackle
                            output[i] = (Math.random() * 2 - 1) * (Math.random() > 0.5 ? 3.0 : 2.0);
                        } else if (staticType > 0.35) {
                            // Medium crackle
                            output[i] = (Math.random() * 2 - 1) * (Math.random() > 0.4 ? 1.5 : 1.0);
                        } else {
                            // Quick hiss
                            output[i] = (Math.random() * 2 - 1) * 0.4;
                        }
                    } else {
                        // Random silence or micro-noise
                        output[i] = (Math.random() > 0.8 ? (Math.random() * 2 - 1) * 0.05 : 0);
                    }
                }

                this.crackleNoiseBuffer = buffer;
                console.log('‚ö°üîä Created SHARP, QUICK, LOUD, RANDOM crackle buffer');
            }

            playVolumeCrackle() {
                if (!this.audioContext || !this.crackleNoiseBuffer) return;

                // Stop existing crackle
                if (this.crackleSource) {
                    try {
                        this.crackleSource.stop();
                    } catch (e) {}
                }

                // Create new crackle source
                this.crackleSource = this.audioContext.createBufferSource();
                this.crackleSource.buffer = this.crackleNoiseBuffer;
                // Connect through ALL THREE filters for ULTRA SHARP texture
                this.crackleSource.connect(this.crackleFilter);
                this.crackleSource.connect(this.crackleFilter2);
                this.crackleSource.connect(this.crackleFilter3);

                // ULTRA LOUD CRACKLE - MAXIMUM volume
                const crackleVolume = Math.max(1.2, Math.min(2.5, this.volume / 20)); // Always at least 120% volume, can go to 250%
                this.crackleGain.gain.setValueAtTime(crackleVolume, this.audioContext.currentTime);
                this.crackleGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05); // QUICK fade

                this.crackleSource.start();
                this.crackleSource.stop(this.audioContext.currentTime + 0.05); // VERY QUICK duration

                console.log(`‚ö°üîä‚ö° ULTRA SHARP CRACKLE at volume: ${crackleVolume.toFixed(2)}`);
            }

            createStaticCrackle() {
                // Create additional static-based crackle for more texture
                const bufferSize = this.audioContext.sampleRate * 0.15; // 0.15 seconds
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    // More varied static pattern
                    const randomFactor = Math.random();
                    if (randomFactor > 0.7) {
                        // Occasional louder static burst
                        output[i] = (Math.random() * 2 - 1) * 1.5;
                    } else if (randomFactor > 0.4) {
                        // Medium static
                        output[i] = (Math.random() * 2 - 1) * 0.8;
                    } else {
                        // Light static or silence
                        output[i] = (Math.random() * 2 - 1) * 0.2;
                    }
                }

                this.staticCrackleBuffer = buffer;
                console.log('‚úÖ Created static crackle buffer');
            }

            updateAtmosphericVolume() {
                if (this.volume === 0) {
                    // Mute all atmospheric audio when volume is 0
                    if (this.whineGain) this.whineGain.gain.value = 0;
                    if (this.humGain) this.humGain.gain.value = 0;
                    if (this.humGain2) this.humGain2.gain.value = 0;
                } else {
                    // Set atmospheric audio volume based on TV volume (very subtle)
                    const whineVolume = Math.min(0.02, this.volume / 5000); // Very soft whine
                    const humVolume = Math.min(0.025, this.volume / 4000);  // Main hum
                    const hum2Volume = Math.min(0.015, this.volume / 6000); // Secondary hum

                    if (this.whineGain) this.whineGain.gain.value = whineVolume;
                    if (this.humGain) this.humGain.gain.value = humVolume;
                    if (this.humGain2) this.humGain2.gain.value = hum2Volume;
                }
            }

            playStaticNoise() {
                try {
                    if (!this.audioContext || !this.whiteNoiseBuffer) {
                        this.createStaticNoise();
                    }

                    // Resume audio context if suspended (required by some browsers)
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }

                    // Stop any existing noise source
                    this.stopStaticNoise();

                    // Create and start new buffer source
                    this.staticNoiseSource = this.audioContext.createBufferSource();
                    this.staticNoiseSource.buffer = this.whiteNoiseBuffer;
                    this.staticNoiseSource.loop = true;
                    this.staticNoiseSource.connect(this.filterNode);

                    // Adjust static noise volume based on TV volume and mute when needed
                    if (this.gainNode) {
                        if (this.volume === 0) {
                            this.gainNode.gain.value = 0; // Completely mute static when volume is 0
                        } else {
                            const staticVolume = Math.min(0.3, this.volume / 200);
                            this.gainNode.gain.value = staticVolume;
                        }
                    }

                    // Start playing
                    this.staticNoiseSource.start(0);
                    console.log('üîä Static noise started');
                } catch (error) {
                    console.log('‚ùå Error playing static noise:', error.message);
                }
            }

            stopStaticNoise() {
                try {
                    if (this.gainNode) {
                        this.gainNode.gain.value = 0;
                    }

                    // Stop and disconnect the buffer source
                    if (this.staticNoiseSource) {
                        try {
                            this.staticNoiseSource.stop();
                            this.staticNoiseSource.disconnect();
                        } catch (e) {
                            // Source might already be stopped
                        }
                        this.staticNoiseSource = null;
                    }

                    console.log('üîá Static noise stopped');
                } catch (error) {
                    console.log('Error stopping static noise:', error.message);
                }
            }

            toggleFullscreen() {
                const tvContainer = document.querySelector('.tv-container');
                const fullscreenBtn = document.getElementById('fullscreenToggle');
                const icon = fullscreenBtn.querySelector('i');
                const fullscreenHint = document.getElementById('fullscreenHint');

                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    tvContainer.requestFullscreen().then(() => {
                        icon.classList.remove('fa-expand');
                        icon.classList.add('fa-compress');
                        fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> EXIT FULLSCREEN';
                        console.log('üì∫ Entered fullscreen mode');

                        // Show exit hint
                        fullscreenHint.style.display = 'block';
                        setTimeout(() => {
                            fullscreenHint.style.display = 'none';
                        }, 3000);
                    }).catch((err) => {
                        console.error('Error attempting to enable fullscreen:', err);
                    });
                } else {
                    // Exit fullscreen
                    document.exitFullscreen().then(() => {
                        icon.classList.remove('fa-compress');
                        icon.classList.add('fa-expand');
                        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> FULLSCREEN';
                        console.log('üì∫ Exited fullscreen mode');
                        fullscreenHint.style.display = 'none';
                    }).catch((err) => {
                        console.error('Error attempting to exit fullscreen:', err);
                    });
                }
            }

            setupEventListeners() {
                this.currentVideoElement.addEventListener('ended', () => {
                    // Always show static between videos, even with preloading
                    this.showStaticBetweenVideos();
                });

                this.currentVideoElement.addEventListener('error', (e) => {
                    const mediaError = this.currentVideoElement.error;
                    const errorDetails = {
                        code: mediaError?.code,
                        message: mediaError?.message,
                        src: this.currentVideoElement.src,
                        readyState: this.currentVideoElement.readyState,
                        networkState: this.currentVideoElement.networkState
                    };
                    console.error('‚ùå Video error:', errorDetails);
                    setTimeout(() => this.playRandomVideo(), 2000);
                });

                document.getElementById('changeChannel').addEventListener('click', () => {
                    if (this.scheduledPlayTimeout) {
                        clearTimeout(this.scheduledPlayTimeout);
                    }
                    this.currentVideoElement.pause();
                    this.currentProgramIndex++;
                    this.onScheduledVideoEnd();
                });

                document.getElementById('fullscreenToggle').addEventListener('click', () => {
                    this.toggleFullscreen();
                });

                // Listen for fullscreen changes to update button state
                document.addEventListener('fullscreenchange', () => {
                    const fullscreenBtn = document.getElementById('fullscreenToggle');
                    const fullscreenHint = document.getElementById('fullscreenHint');
                    if (!document.fullscreenElement) {
                        // Exited fullscreen
                        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> FULLSCREEN';
                        fullscreenHint.style.display = 'none';
                    }
                });

                // Escape key listener to exit fullscreen
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const tv = new Schwelevision();
            await tv.init();
        });
    </script>
</body>
</html>
